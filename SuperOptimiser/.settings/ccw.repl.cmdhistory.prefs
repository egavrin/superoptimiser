cmdhistory=["(use 'Opcodes)" "(opcode-sequence 2)" "1" "2" "(opcode-sequence 4)" "(mapcat identity (((\:istore 0 \:istore 0) (\:istore 0 \:istore 1) (\:istore 1 \:istore 0) (\:istore 1 \:istore 1)) ((\:ixor \:ireturn))))" "(mapcat identity '(((\:istore 0 \:istore 0) (\:istore 0 \:istore 1) (\:istore 1 \:istore 0) (\:istore 1 \:istore 1)) ((\:ixor \:ireturn))))" "(mapcat identity '((\:istore 0 \:istore 0) (\:istore 0 \:istore 1) (\:istore 1 \:istore 0) (\:istore 1 \:istore 1)) ((\:ixor \:ireturn)))" "(mapcat identity '(((a b) (c d))((e f))))" "(mapcat identity '((a b) (c d))((e f)))" "1" "(nthrest '(\:a \:b \:c \:d \:e) 2)" "(nthrest 2 '(\:istore \:arg \:ireturn))" "(use org.tomhume.so.Opcodes)" "(use 'org.tomhume.so.Opcodes)" "(opcodes \:pop)" "((opcodes \:pop) \:opcode)" "(new InsnNode 87)" "(new InsnNode ((opcodes \:pop) \:opcode))" "(. (new InsnList) add (new InsnNode ((opcodes \:pop) \:opcode)))" "(next '(1 2 3))" "\:arg" "(\:arg)" "(first '[ 1 2 3])" "(second '[ 1 2 3])" "(nthrest '(1 2 3 4) 0)" "(opcodes \:pop)" "(((opcodes \:istore) \:args) count)" "(opcodes \:istore)" "((opcodes \:istore) \:args)" "(count ((opcodes \:istore) \:args))" "(ns some.Example\\n  (\:gen-class))\\n\\n(defn -toString\\n  [this]\\n  \\"Hello, World\!\\")" "(some.Example.)" "(-toString (some.Example.))" "(use 'some.Example)" "('some.Example/-toString)" "(-toString (some.Example.))" "(gen-and-load-class 'foo.MyClass\\n   \:methods [['mymethod [String] String]\\n             ['finalize [] Void/TYPE]])" "(ns test.test\\n    (\:gen-class))\\n\\n(defn -main\\n    [gre]\\n    (println (str \\"Hello \\" gre)))" "(test.test)" "(compile 'test.test)" "(test.test.)" "(ns some.Example\\n  (\:gen-class))\\n\\n(defn -toString\\n  [this]\\n  \\"Hello, World\!\\")" "(-toString (some.Example.))" "(ns org.tomhume.so.Bytecode)" "(reflect ClassLoader)" "(use 'clojure.reflect)" "(reflect ClassLoader)" "(reflect ClassLoader \:members)" "(def test-proxy (proxy [Object] [] (test-method [] (println \\"a\\"))))" "text-proxy" "test-proxy" "(test-method test-proxy)" "(test-proxy test-method)" "(.test-method test-proxy)" "(def test-proxy (proxy [Object] [] (testMethod [] (println \\"a\\"))))" "(.testMethod test-proxy)" "(type test-proxy)" "(do-reflect test-proxy)" "(reflect test-proxy)" "(class test-proxy)" "(def test-proxy (proxy [Object] [] (toString [] (println \\"a\\"))))" "(.toString test-proxy)" "(def test-proxy (proxy [ClassLoader] [] (defineClass [name bytes offset len] (proxy-super name bytes offset len))))" "(.defineClass test-proxy \\"a\\" \\"b\\" 0 1)" "(def test-proxy (proxy [ClassLoader] [] (defineClass [name bytes offset len] (proxy-super defineClass name bytes offset len))))" "(.defineClass test-proxy \\"a\\" \\"b\\" 0 1)" "(reflect test-proxy)" "(use 'clojure.reflect)" "(reflect cg)" "(.dummy cg)" "(-dummy cg)" "(.dummy cg)" "(class cg)" "(.dummy cg)" "(-dummy cg)" "(.dummy cg a)" "(.dummy cg 'a)" "(.dummy cg)" "(-dummy cg)" "cg" "(class cg)" "(use 'clojure.reflect)" "(reflect cg)" "(.dummy cg)" "(-dummy cg)" "(reload-class 'a l)" "(reload-class 'a 'l)" "(use 'clojure.reflect)" "(reflect f)" "(reflect f1)" "(reflect f2)" "(reflect f1)" "(reflect f2)" "(.identity f1 1)" "f1" "(class f1)" "(def method (.getDeclaredMethod f1 \\"identity\\" Integer/TYPE))" "(.getDeclaredMethod f1 \\"identity\\" 1)" "(reflect f1)" "(type f1)" "(.identity f1)" "(.identity f1 1)" "(f1/identity 1)" "(IdentityTest1/identity 1)" "(IdentityTest1/identity)" "(type f1)" "(import IdentityTest1)" "(class f1)" "(reflect f1)" "(identity f1)" "(id f1)" "(f1 id)" "(reflect f1)" "(reflect f2)" "(id_two f2)" "(.id_two f2)" "(.idTwo IdentityTwo 1)" "(.idTwo IdentityTest-2 1)" "(IdentityTestTwo/idTwo 1)" "(IdentityTest-2)" "(IdentityTest-2/idTwo 2)" "(IdentityTest-2/id_two 2)" "(IdentityTest-1/id_two 2)" "(IdentityTest-1/identity 2)" "(f1/identity 2)" "(type f1)" "(. ~f1)" "(. ~f1 identity 1)" "(import 'clojure.lang.Reflector)" "(import clojure.lang.Reflector)" "(import 'clojure.lang.Reflector)" "(Reflector/invokeStaticMethod Integer \\"parseInt\\" (into-array [\\"1\\"]))" "(defmacro static-call [var method & args]\\n  `(-> (.getName ~var)\\n       (symbol ~(str method))\\n       (list ~@args)\\n       eval))" "(static-call \\"IdentityTest-2\\" \\"identity\\" 1)" "(static-call f1 'identity 1)" "(static-call f1 \\n             \\"identity\\" 1)" "opcodes" "1" "(def f1 (get-class '(\:iload 0 \:ireturn) \\"IdentityTest-1\\" \\"identity\\" \\"(I)I\\"))" "type f1" "(type f1)" "(def f1 (get-class '(\:iload 0 \:ireturn) \\"IdentityTest-1\\" \\"identity\\" \\"(I)I\\"))" "(mapcat identity (map expand-opcodes (opcode-sequence 2)))" "(map \#(println (\:code %))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2))))" "(map \#(println (% \:code))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2))))" "(map \#(println %)\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2))))" "(count (map \#(println %)\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(count (map \#(println (first %))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(count (map \#(println (\:code %))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(count (map \#(println (\:code %))\\n     (first (mapcat identity (map expand-opcodes (opcode-sequence 2))))))" "(count (map \#(println %)\\n     (first (mapcat identity (map expand-opcodes (opcode-sequence 2))))))" "(first (map \#(println %)\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(first (map expand-opcodes (opcode-sequence 2)))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'org.tomhume.so.Opcodes)))" "(first (map \#(println %)\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(first (map \#(println (\:code %))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(let [seqnum 0]\\n  (4 seqnum))" "(System/gc)" "\\n(defn a \\"\\" [] (try (do (1/0) true) (catch Exception e false)))" "(defn a \\"\\" [b] (try (do (1/b) true) (catch Exception e false)))" "(defn a \\"\\" [b] (try (1/b) (catch Exception e 999))\\n  )" "(defn a \\"\\" [b] (try (/ 1 b) (catch Exception e 999)))" "(a 1)" "(a 0)" "(defn a \\"\\" [b] (try (> 0 (/ 1 b)) (catch Exception e 999)))" "(a 1)" "(a 0.1)" "(defn a \\"\\" [b] (try (> (/ 1 b) 0) (catch Exception e 999)))" "(a 1)" "(a 0.1)" "(a 0)" "(defn a \\"\\" [b] (try (> (/ 1 b) 0) (catch Exception e false)))" "(a 0)" "(def newInt (new Integer))" "(def newInt (new Integer 3))" "newInt" "(static-call newInt \\"parseInt\\" \\"1\\")" "(static-call (class newInt) \\"parseInt\\" \\"1\\")" "(static-call (class newInt) \\"parseInt\\" \\"123\\")" "(class meth-name)" "(def meth-name \\"parseInt\\")" "(static-call (class newInt meth-name \\"123\\"))" "(static-call (class newInt) meth-name \\"123\\")" "(symbol meth-name)" "(defmacro static-call [var method & args]\\n     `(-> (.getName ~var)\\n          (symbol ~method)\\n          (list ~@args)\\n          eval))" "(ns-unmap 'org.tomhume.so.Bytecode static-call)" "(ns-unmap 'org.tomhume.so.Bytecode 'static-call)" "(defmacro static-call [var method & args]\\n        `(-> (.getName ~var)\\n             (symbol ~method)\\n             (list ~@args)\\n             eval))" "(static-call (class newInt) meth-name \\"123\\")" "(import 'clojure.lang.Reflector)" "(Reflector/invokeStaticMethod Integer meth-name (into-array [\\"1\\"]))" "(map expand-opcodes (opcode-sequence 2))" "(map-indexed expand-opcodes (opcode-sequence 2))" "(expanded-numbered-opcode-sequence 2)" "(range 0 0)" "1" "(expanded-numbered-opcode-sequence 3 1)" "1" "(count (expanded-numbered-opcode-sequence 3 1))" "(mod 2 3)" "(mod 100 10)" "(mod 101 10)" "(let [num 1001] (doall (if (\= (0 (mod num 1000))) (println num))))" "(let [num 1001] (if (\= (0 (mod num 1000))) (println num)))" "(if (\= 0 (mod num 1000)) (println \\"hello\\"))" "(if (\= 0 (mod 1001 1000)) (println \\"hello\\"))" "(if (\= 0 (mod 2000 1000)) (println \\"hello\\"))" "(ns-publics 'org.tomhume.so.Main)" "(ns-publics 'org.tomhume.so.IdentitySO)" "(ns-publics 'org.tomhume.so.LoadManyClasses)" "1" "(count (expanded-numbered-opcode-sequence 3 1))" "(ns 'org.tomhume.so.Opcodes)" "(use 'org.tomhume.so.Opcodes)" "(count (expanded-numbered-opcode-sequence 3 1))" "(Reflector/invokeStaticMethod \\"java.lang.Math\\" max (into-array '[1 2]))" "(into-array '[3 2])" "(int 2)" "(count (expanded-numbered-opcode-sequence 4 2))" "(opcodes \:ixor)" "(\:ixor opcodes)" "opcodes" "(use 'org.tomhume.so.Opcodes)" "(\:ixor opcodes)" "(\:operand-needs (\:ixor opcodes))" "(\:opstack-needs (\:ixor opcodes))" "(first [\:ixor])" "((first [\:ixor]) opcodes)" "(\:opstack-needs ((first [\:ixor]) opcodes))" "(< (\:opstack-needs ((first [\:ixor]) opcodes)) 0)" "(if (< (\:opstack-needs ((first [\:ixor]) opcodes)) 0) false)" "(if (< (\:opstack-needs ((first [\:ixor]) opcodes)) 0) false true)" "(\= 0 (\:opstack-effect (\:ixor opcodes)))" "(+ 0 (\:opstack-effect (\:ixor opcodes)))" "(uses-operand-stack-ok? [\:ixor])" "(or (\= 1 1) (\= 1 0))" "(rest [\:ixor])" "(< (\:opstack-needs (\:ixor opcodes)) 0)" "(> (\:opstack-needs (\:ixor opcodes)) 0)" "(count (expanded-numbered-opcode-sequence 1 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 2 2))" "(count (expanded-numbered-opcode-sequence 2 3))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 3 2))" "(count (expanded-numbered-opcode-sequence 1 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 2 2))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 3 2))" "(count (expanded-numbered-opcode-sequence 1 1))" "(count (expanded-numbered-opcode-sequence 1 2))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 2 2))" "(count (expanded-numbered-opcode-sequence 3 1))" "(expanded-numbered-opcode-sequence 2 1)" "(use 'org.tomhume.so.Opcodes)" "(expanded-numbered-opcode-sequence 2 1)" "(use 'org.tomhume.so.Opcodes)" "1" "(def a {})" "(0 a)" "(get a 0)" "(put a 0 1)" "(assoc a 0 1)" "a" "(get (assoc a 0 1) 0)" "(\= \:load_0 \:iload_0)" "(\= \:iload_0 \:iload_0)" "(count (expanded-numbered-opcode-sequence 3 1))" "(assoc {} nil)" "(assoc {} nil nil)" "(count (\:args (\:ixor opcodes)))" "(count (\:args (\:istore opcodes)))" "(nthrest 1 '[1 2 3 4])" "(nthrest '[1 2 3 4] 1)" "(nthrest (+ 1 (count (\:args (\:istore opcodes)))) '[1 2 3 4] head)" "(nthrest (+ 1 (count (\:args (\:istore opcodes)))) '[1 2 3 4])" "(class opcodes)" "(+ 1 (count (\:args (\:istore opcodes))))" "(update-varmap '[\:iload_0])" "(assoc {} (update-varmap '[\:iload_0]))" "(partial assoc {} (update-varmap '[\:iload_0]))" "((partial assoc) {} (update-varmap '[\:iload_0]))" "((partial assoc {}) (update-varmap '[\:iload_0]))" "(partial assoc {})" "(let [map (update-varmap '[\:iload_0])]\\n  (assoc {} (nth map 0) (nth map 1)))" "(get '{0 \:write} 0)" "(update-varmap '[\:iload 12])" "(update-varmap '[\:iload_3])" "(update-varmap '[\:iload 12])" "(\= '(12 \:write) (update-varmap '[\:iload 12]))" "(update-varmap '[\:ixor])" "(update-varmap '[\:iload 12])" "(assoc {} (update-varmap '[\:iload 12]))" "(partial (assoc {}) (update-varmap '[\:iload 12]))" "((partial assoc) {} (update-varmap '[\:iload 12]))" "(update-varmap '[\:iload 12])" "(assoc {} (nth (update-varmap '[\:iload 12]) 1) (nth (update-varmap '[\:iload 12]) 2))" "(assoc {} (nth (update-varmap '[\:iload 12]) 0) (nth (update-varmap '[\:iload 12]) 1))" "(update-varmap '[\:iload 0])" "(update-varmap '[\:istore_0])" "(uses-vars-ok? [\:istore_0 \:iload 0 \:istore_0])" "(doc next)" "(nth '[1 2 3] 2)" "(uses-vars-ok? [\:istore_0 \:iload 0 \:istore_0])" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 4 1))" "(time \\n  (doall\\n        (superoptimise 2 class-name method-name method-signature eq-tests-filter)))" "(use 'org.tomhume.so.IdentitySO)" "(apply concat\\n       (pmap \#(%) (partition-all 10 (range 0 1000))))" "(apply concat (pmap \#(identity %) (partition-all 10 (range 0 1000))))" "(into {} (map \#(identity %) (range 0 2)))" "(into [] (map \#(identity %) (range 0 2)))" "(into {} (map \#((identity %) \:write) (range 0 2)))" "(into {} (map \#([(identity %) \:write]) (range 0 2)))" "(into {} (map \#(assoc {} (identity %) \:write)) (range 0 2))" "(into {} (map \#(assoc {} (identity %) \:write) (range 0 2)))" "(into {} (map \#(assoc {} (identity %) \:write) (range 0 nil)))" "(> 0 nil)" "(range 0 1)" "num-args" "method-signature" "1" "(count (expanded-numbered-opcode-sequence 1 1))" "(use 'org.tomhume.so.Main)" "(count (expanded-numbered-opcode-sequence 1 1))" "(use 'org.tomhume.so.Opcodes)" "(count (expanded-numbered-opcode-sequence 1 1))" "(time (doall (expanded-numbered-opcode-sequence 1 1)))" "(time (doall (expanded-numbered-opcode-sequence 2 1)))" "(time (doall (count (expanded-numbered-opcode-sequence 2 1))))" "(time  (count (expanded-numbered-opcode-sequence 2 1)))" "(time  (count (expanded-numbered-opcode-sequence 3 1)))" "(time  (count (expanded-numbered-opcode-sequence 4 1)))"]
eclipse.preferences.version=1
