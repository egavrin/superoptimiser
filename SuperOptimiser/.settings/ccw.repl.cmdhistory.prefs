cmdhistory=["(update-varmap '[\:iload 12])" "(assoc {} (update-varmap '[\:iload 12]))" "(partial (assoc {}) (update-varmap '[\:iload 12]))" "((partial assoc) {} (update-varmap '[\:iload 12]))" "(update-varmap '[\:iload 12])" "(assoc {} (nth (update-varmap '[\:iload 12]) 1) (nth (update-varmap '[\:iload 12]) 2))" "(assoc {} (nth (update-varmap '[\:iload 12]) 0) (nth (update-varmap '[\:iload 12]) 1))" "(update-varmap '[\:iload 0])" "(update-varmap '[\:istore_0])" "(uses-vars-ok? [\:istore_0 \:iload 0 \:istore_0])" "(doc next)" "(nth '[1 2 3] 2)" "(uses-vars-ok? [\:istore_0 \:iload 0 \:istore_0])" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 4 1))" "(time \\n  (doall\\n        (superoptimise 2 class-name method-name method-signature eq-tests-filter)))" "(use 'org.tomhume.so.IdentitySO)" "(apply concat\\n       (pmap \#(%) (partition-all 10 (range 0 1000))))" "(apply concat (pmap \#(identity %) (partition-all 10 (range 0 1000))))" "(into {} (map \#(identity %) (range 0 2)))" "(into [] (map \#(identity %) (range 0 2)))" "(into {} (map \#((identity %) \:write) (range 0 2)))" "(into {} (map \#([(identity %) \:write]) (range 0 2)))" "(into {} (map \#(assoc {} (identity %) \:write)) (range 0 2))" "(into {} (map \#(assoc {} (identity %) \:write) (range 0 2)))" "(into {} (map \#(assoc {} (identity %) \:write) (range 0 nil)))" "(> 0 nil)" "(range 0 1)" "num-args" "method-signature" "1" "(count (expanded-numbered-opcode-sequence 1 1))" "(use 'org.tomhume.so.Main)" "(count (expanded-numbered-opcode-sequence 1 1))" "(use 'org.tomhume.so.Opcodes)" "(count (expanded-numbered-opcode-sequence 1 1))" "(time (doall (expanded-numbered-opcode-sequence 1 1)))" "(time (doall (expanded-numbered-opcode-sequence 2 1)))" "(time (doall (count (expanded-numbered-opcode-sequence 2 1))))" "(time  (count (expanded-numbered-opcode-sequence 2 1)))" "(time  (count (expanded-numbered-opcode-sequence 3 1)))" "(time  (count (expanded-numbered-opcode-sequence 4 1)))" "1" "(def cl (get-class (\:iload 0 \:bipush 2 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(use 'org.tomhume.so.Bytecode)" "(def cl (get-class (\:iload 0 \:bipush 2 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(def cl (get-class '(\:iload 0 \:bipush 2 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(invoke-method cl \\"signum\\" 1)" "(invoke-method cl \\"signum\\" 123123123)" "(invoke-method cl \\"signum\\" 0)" "(invoke-method cl \\"signum\\" 75084750234750983750982347)" "(invoke-method cl \\"signum\\" -1)" "(invoke-method cl \\"signum\\" Integer/MAXINT)" "(invoke-method cl \\"signum\\" Integer/MAXVALUE)" "(invoke-method cl \\"signum\\" Integer/MAX_VALUE)" "(invoke-method cl \\"signum\\" Integer/MIN_VALUE)" "(invoke-method cl \\"signum\\" -9283798274)" "(invoke-method cl \\"signum\\" -999)" "(invoke-method cl \\"signum\\" -10234)" "(def cl (get-class '(\:iload 0 \:bipush 254 \:irem \:return) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(def cl (get-class '(\:iload 0 \:bipush 254 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(invoke-method cl \\"signum\\" -10234)" "(invoke-method cl \\"signum\\" -999)" "(def cl (get-class '(\:iload 0 \:iconst_2 \:item \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(def cl (get-class '(\:iload 0 \:iconst_2 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(invoke-method cl \\"signum\\" -999)" "(invoke-method cl \\"signum\\" -10123)" "(invoke-method cl \\"signum\\" Integer/MAX_VALUE)" "(invoke-method cl \\"signum\\" Integer/MIN_VALUE)" "(invoke-method cl \\"signum\\" -999999)" "(invoke-method cl \\"signum\\" (+ 1 Integer/MIN_VALUE))" "(invoke-method cl \\"signum\\" Integer/MIN_VALUE)" "(Integer/MIN_VALUE)" "(def i (new Integer))" "(def i (new Integer Integer/MIN_VALUE))" "(.signum i)" "(123 Integer/signum)" "(Integer/signum 123)" "(Integer/signum Integer/MIN_VALUE)" "(Integer/signum Integer/MAX_VALUE)" "(invoke-method cl \\"signum\\" (+ 1 Integer/MIN_VALUE))" "(invoke-method cl \\"signum\\" (+ 2 Integer/MIN_VALUE))" "(invoke-method cl \\"signum\\" (+ 3 Integer/MIN_VALUE))" "(invoke-method cl \\"signum\\" (+ 4 Integer/MIN_VALUE))" "(expanded-numbered-opcode-sequence 2 1)" "(use 'org.tomhume.so.Opcodes)" "(expanded-numbered-opcode-sequence 2 1)" "(map \#(assoc % \:class (get-class (\:code %)  \\"IdentityTest\\" \\"identity\\" \\"(I)I\\" ))\\n             (expanded-numbered-opcode-sequence 2 (num-method-args \\"(I)I\\")))" "(def cl (get-class '(\:iload_0 \:ireturn) \\"Identity\\" \\"identity\\" \\"(I)I\\"))" "cl" "(check-passes eq-tests-filter cl)" "eq-tests-filter" "(defn one-is-one? [i] (\= 1 (invoke-method i method-name 1)))\\n(defn zero-is-zero? [i] (\= 0 (invoke-method i method-name 0)))\\n(defn minus-one-is-minus-one? [i] (\= -1 (invoke-method i method-name -1)))\\n(defn minint-is-minint? [i] (\= Integer/MIN_VALUE (invoke-method i method-name Integer/MIN_VALUE)))\\n(defn maxint-is-maxint? [i] (\= Integer/MAX_VALUE (invoke-method i method-name Integer/MAX_VALUE)))\\n(defn one-is-not-zero? [i] (not (\= 1 (invoke-method i method-name 0))))\\n(defn one-is-not-minus-one? [i] (not (\= 1 (invoke-method i method-name -1))))\\n\\n(def eq-tests-filter (test-map [one-is-one? zero-is-zero? minus-one-is-minus-one? minint-is-minint? maxint-is-maxint? one-is-not-zero? one-is-not-minus-one?]))" "(def class-name \\"IdentityTest\\")\\n(def method-name \\"identity\\")\\n(def method-signature \\"(I)I\\")\\n\\n; set up a map of equivalence tests\\n\\n(defn one-is-one? [i] (\= 1 (invoke-method i method-name 1)))\\n(defn zero-is-zero? [i] (\= 0 (invoke-method i method-name 0)))\\n(defn minus-one-is-minus-one? [i] (\= -1 (invoke-method i method-name -1)))\\n(defn minint-is-minint? [i] (\= Integer/MIN_VALUE (invoke-method i method-name Integer/MIN_VALUE)))\\n(defn maxint-is-maxint? [i] (\= Integer/MAX_VALUE (invoke-method i method-name Integer/MAX_VALUE)))\\n(defn one-is-not-zero? [i] (not (\= 1 (invoke-method i method-name 0))))\\n(defn one-is-not-minus-one? [i] (not (\= 1 (invoke-method i method-name -1))))\\n\\n(def eq-tests-filter (test-map [one-is-one? zero-is-zero? minus-one-is-minus-one? minint-is-minint? maxint-is-maxint? one-is-not-zero? one-is-not-minus-one?]))" "eq-tests-filter" "(check-passes eq-tests-filter cl)" "(passes? eq-tests-filter cl)" "\u00AC(import 'java.lang.Runtime) \\n(.maxMemory (Runtime/getRuntime))" "(import 'java.lang.Runtime) \\n(.maxMemory (Runtime/getRuntime))" "(get-children '[])" "(repeat 3 (rand-opcode-sequence 2))" "(rand-opcode-sequence 2)" "(repeatedly 3 (rand-opcode-sequence 2))" "(repeatedly 3 (partial rand-opcode-sequence 2))" "(rand-opcode-sequence 2)" "(repeatedly 3 (partial rand-opcode-sequence 2))" "(reduce + (partial (count (get-children)) (repeatedly 3 (partial rand-opcode-sequence 2))))" "(reduce (partial (+ count(get-children))) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce (partial + count get-children)) (repeatedly 3 (partial rand-opcode-sequence 2))" "(reduce + '[1 2 3 4])" "(repeatedly 3 (partial rand-opcode-sequence 2))" "reduce count (repeatedly 3 (partial rand-opcode-sequence 2))" "(reduce count (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce identity (repeatedly 3 (partial rand-opcode-sequence 2)))" "(repeatedly 3 (partial rand-opcode-sequence 2))" "(reduce (+ count) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce (partial + count) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce (partial (+ (count))) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce \#(+ (count %)) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce \#(+ (count %1) %2) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce \#(+ (count %2) %1) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(map \#(count (get-children %)) ((repeatedly 3 (partial rand-opcode-sequence 2))))" "(map \#(get-children %) ((repeatedly 3 (partial rand-opcode-sequence 2))))" "(map \#(get-children %) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(map \#(count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce + (map \#(count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 2))))" "(prune-stats 1)" "(prune-stats)" "(prune-stats 1)" "(def xyz 1)" "(range 1 (inc xyz))" "(prune-stats 1)" "(prune-stats 2)" "(/ 99 3)" "(prune-stats 2)" "(count (keys opcodes))" "(count keys opcodes)" "(reduce * (prune-stats 2))" "(* 39 39)" "(reduce * (prune-stats 6))" "(reduce * (prune-stats 12))" "(reduce * (prune-stats 11))" "(reduce * (prune-stats 2))" "(rand-opcode-sequence 10)" "(prune-stats 2)" "(prune-stats 0)" "(prune-stats 1)" "(prune-stats 2)" "(prune-stats 3)" "(prune-stats 2)" "(rand-opcode-sequence 2)" "(rand-opcode-sequence 3)" "(filter is-valid? (get-children '[\:ixor]))" "(filter is-valid? (get-children '[]))" "(prune-stats 2)" "(rand-opcode-sequence 3)" "(prune-stats 2)" "(get-children (keys opcodes))" "(map get-children (keys opcodes))" "(keys opcodes)" "(map get-children (seq (keys opcodes)))" "(map \#(get-children [%]) (keys opcodes))" "(prune-stats 2)" "(prune-stats 6)" "(repeatedly 3 (partial rand-opcode-sequence 4))" "((map \#(count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 4))))" "(map \#(count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 4)))" "(map \#((do (println %) (count (get-children %))) (repeatedly 3 (partial rand-opcode-sequence 4))))" "(map \#(do (println %) (count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 4))))" "(map \#(do (println %) (count (get-children %))) (repeatedly 3 (partial rand-opcode-sequence 4)))" "(count (get-children '(\:iconst_3 \:iconst_3 \:iconst_3 \:iconst_5))\\n       )" "(prune-stats 10)" "(prune-stats 3)" "(uses-operand-stack-ok? '(\:i2b \:iconst_4 \:iinc \:iconst_2))" "(uses-operand-stack-ok? '(\:ireturn \:iconst_4 \:iinc \:iconst_2))" "(uses-operand-stack-ok? '(\:iconst_4 \:iconst_4 \:iinc \:iconst_2))" "(prune-stats 12)" "(get-children '())" "(get-children '(\:iinc))" "(conj '(\:ixor) \:iinc)" "(conj '[\:ixor] \:iinc)" "(get-children '[\:iinc])" "(prune-stats 12)" "(prune-stats 6)" "(reduce * (prune-stats 6))" "(reduce (repeat 5 39))" "(repeat 5 39)" "(reduce * (repeat 5 39))" "(reduce * (prune-stats 6))" "(prune-stats 6)" "(reduce * '(34.0 33.78 34.9 33.15 32.81))" "(int (reduce * '(34.0 33.78 34.9 33.15 32.81)))" "(reduce * (repeat 5 39))" "(prune-stats 6)" "(subset?)" "(prune-performance 1)" "(prune-performance 2)" "(/ 79 100)" "(reduce * (prunt-stats 2))" "(reduce * (prune-stats 2))" "(reduce * (repeat (dec 2) (count (keys opcodes))))" "(count (keys opcodes))" "(prune-performance 3)" "(/ 100 79)" "(prune-performance 2)" "(prune-performance 3)" "(prune-performance 4)" "(prune-performance 5)" "(prune-performance 6)" "(prune-stats 6)" "(reduce * '(33.141 33.4304 33.2245 33.3556 33.254))" "(int (reduce * '(33.141 33.4304 33.2245 33.3556 33.254)))" "(reduce * (repeat 5 47))" "(reduce * (repeat 5 39))" "(reduce * (repeat 4 47))" "(count (get-children '[]))" "(rand-opcode-sequence 1)" "(prune-stats 6)" "(prune-stats 0)" "(prune-stats 1)" "(prune-stats 2)" "(prune-stats 3)" "(repeatedly 2 (partial rand-opcode-sequence 1))" "(map \#(count (get-children %)) (repeatedly 2 (partial rand-opcode-sequence 1)))" "(get-children '[\:iconst_m1])" "(count (get-children '[\:iconst_m1]))" "(count (get-children '[\:pop]))" "(count (get-children '[]))" "(range 0 4)" "(rand-opcode-sequence 0)" "(count (get-children (rand-opcode-sequence 0)))" "(map \#(count (get-children %))\\n\\t                 (repeatedly num-tests (partial rand-opcode-sequence 0)))" "(map \#(count (get-children %))\\n\\t                 (repeatedly 50 (partial rand-opcode-sequence 0)))" "(reduce + '(10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10))" "(/ 500 50)" "(prune-stats 5)" "(prune-stats 12)" "(map \#(float (% / 39)) '(10.0 20.8072 28.3805 30.2772 32.0268 32.607 33.4567 33.847 34.292 34.571 34.7561 35.0472))" "(map \#(float (/ % 39)) '(10.0 20.8072 28.3805 30.2772 32.0268 32.607 33.4567 33.847 34.292 34.571 34.7561 35.0472))" "(reduce * '(10.0 20.8072 28.3805 30.2772))" "(reduce * '(10.0 20.8072 28.3805 30.2772 500))" "(int (reduce * '(10.0 20.8072 28.3805 30.2772 500)))" "(reduce * '(39 39 39 39))" "(/ 178792.5398261712 2313441)" "(prune-stats 3)" "(prune-performance 6)" "(prune-performance 1)" "(reduce * (prune-stats 1))" "(prune-performance 1)" "(prune-performance 6)" "(prune-performance 12)" "(prune-performance 9)" "(prune-performance 1)" "(prune-performance 2)" "(* 0.052935 (reduce * (repeat 6 39)))" "(int (* 0.052935 (reduce * (repeat 6 39))))" "(int (* (prune-performance 5) (reduce * (repeat 6 39))))" "(reduce * (repeat 6 39))" "(redundant-pairs)" "redundant-pairs" "(def redundant-pairs '(\\n                        [\:swap \:swap]       ; Two swaps leave things as they were\\n                        [\:pop \:pop]         ; Could be replaced by \:pop2\\n                        ))" "redundant-pairs" "(reduce \#(%1 %2) redundant-pairs)" "(reduce \#(%) redundant-pairs)" "(map % redundant-pairs)" "(map \#(%) redundant-pairs)" "(map \#(first %) redundant-pairs)" "(reduce \#(first %) redundant-pairs)" "(first '[1 2 3])" "(next '[1 2 3])" "(second '[1 2 3])" "(contains-no-redundant-pairs? '[\:ixor \:swap \:swap])" "(doc contains-no-redundant-pairs?)" "(contains-no-redundant-pairs? '[\:ixor \:swap \:swap])" "(use 'org.tomhume.so.Opcodes)" "(contains-no-redundant-pairs? '[\:ixor \:swap \:swap])" "(loop [current '[1 2 3]]\\n       (if empty? current) true (recur (rest current)))" "(rest '[1 2 3])" "(.indexOf '(1 2 3) 2)" "(.indexOf '(1 2 3) 3)" "(for [l '[1 2 3]] l)" "(loop [l '[1 2 3 4]]\\n  (recur (rest l)))" "1" "(loop [l '[1 2 3 4]]\\n  (if empty? l) true\\n  (recur (rest l)))" "(loop [l '[1 2 3 4]]\\n  (println l)\\n  (if empty? l) true\\n  (recur (rest l)))" "(loop [l '[1 2 3 4]]\\n  ((println l)\\n  (if empty? l) true\\n  (recur (rest l))))" "(loop [l '[1 2 3 4]]\\n  (println l)\\n  (if (empty? l) true\\n    (recur (rest l))))" "1" "2" "(loop [l '[1 2 3 4]]\\n     (println \\"Hahahah\\" l)\\n     (if (empty? l) true\\n       (recur (rest l))))" "(loop [l '(1 2 3 4)]\\n     (println \\"Hahahah\\" l)\\n     (if (empty? l) true\\n       (recur (rest l))))" "1" "(loop [l '(1 2 3 4)]\\n   (if (empty? l) true\\n     (do \\n       (println \\"Not empty yet\\")\\n       (recur (rest l)))))" "(contains-no-redundant-pairs? '[\:pop \:pop])" "(contains-no-redundant-pairs? '[\:swap \:swap])" "(contains-no-redundant-pairs? '[\:swap \:pop])" "(contains-no-redundant-pairs? '[\:swap \:pop \:pop])" "(prune-stats 6)" "(use 'org.tomhume.so.PruningTests)" "(prune-stats 6)" "(prune-stats 8)" "1" "(opcode-sequence 2)" "(count (opcode-sequence 2))" "(count (opcode-sequence 3))" "(count (opcode-sequence 4))" "(count (opcode-sequence 3))" "(count (opcode-sequence 4))" "(time (count (opcode-sequence 4)))" "(opcode-sequence 2)" "(opcode-sequence 3)" "(count (opcode-sequence 3))" "(count (keys opcodes))" "(* 40 40)" "(count (opcode-sequence 3))" "(opcode-sequence 3)" "(count (opcode-sequence 3))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 3 2))" "(count (opcode-sequence 4 1))" "(time (count (opcode-sequence 4 1)))" "(take 10 (opcode-sequence 4 1))" "(count (opcode-sequence 4 1))" "(take 10 (opcode-sequence 4 1))" "(take 1 (opcode-sequence 4 1))" "(count (opcode-sequence 4 1))" "(time (count (opcode-sequence 4 1)))" "\u03C0" "(time (count (opcode-sequence 4 1)))" "(time (count (opcode-sequence 5 1)))" "(time (count (opcode-sequence 4 1)))" "(count (keys opcodes))" "(^ 39 4)" "(get-instructions '(\:iload_0 \:ireturn))" "(use 'org.tomhume.so.Bytecode)" "(get-instructions '(\:iload_0 \:ireturn))" "(.get (get-instructions '(\:iload_0 \:ireturn)) 0)" "(.opcode (.get (get-instructions '(\:iload_0 \:ireturn)) 0))" "(.getOpcode (.get (get-instructions '(\:iload_0 \:ireturn)) 0))" "1" "(count (expanded-numbered-opcode-sequence 3 1))" "(time (count (expanded-numbered-opcode-sequence 3 1)))" "(prunt-stats 6)" "(prune-stats 6)" "(use 'org.tomhume.so.PruningTests)" "(prune-stats 6)" "(get-children 1 '[])" "(count (get-children 1 '[]))" "(prune-stats 1)" "(count (get-children 1 '[\:ireturn]))" "(count (get-children 1 '[\:ixor]))" "(count (get-children 1 '[\:iconst_1]))" "(prune-stats 6)" "(prune-stats 2)" "(count (opcode-sequence 2 1))" "(count (let [fertile-children (partial get-children 1)]\\n  (rest (tree-seq \#(< (count 2) max-depth) fertile-children '[]))))" "(count (let [fertile-children (partial get-children 1)]\\n  (rest (tree-seq \#(< (count %) 2) fertile-children '[]))))" "(count (let [fertile-children (partial get-children 1)]\\n  (rest (tree-seq \#(< (count %) 3) fertile-children '[]))))" "(count (let [fertile-children (partial get-children 1)]\\n  (rest (tree-seq \#(< (count %) 1) fertile-children '[]))))" "(count (let [fertile-children (partial get-children 1)]\\n  (rest (tree-seq \#(< (count %) 4) fertile-children '[]))))" "(count (let [fertile-children (partial get-children 1)]\\n  (rest (tree-seq \#(< (count %) 5) fertile-children '[]))))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (expanded-numbered-opcode-sequence 1 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 4 1))" "(take 100 (expanded-numbered-opcode-sequence 3 1))" "(take 200 (expanded-numbered-opcode-sequence 3 1))" "(take 400 (expanded-numbered-opcode-sequence 3 1))" "(take 1000 (expanded-numbered-opcode-sequence 3 1))" "(take 5000 (expanded-numbered-opcode-sequence 3 1))" "(take 1 (expanded-numbered-opcode-sequence 3 1))" "(take 5000 (expanded-numbered-opcode-sequence 3 1))" "(first (drop 2068 (expanded-numbered-opcode-sequence 3 1)))" "(first (drop 2068 (opcode-sequence 3 1)))" "(count (opcodode-sequence 3 1))" "(count (opcode-sequence 3 1))" "(opcode-sequence 3 1)" "(first (drop 30 (opcode-sequence 3 1)))" "(first (drop 2068 (opcode-sequence 3 1)))" "(first (drop 2068 (expanded-numbered-opcode-sequence 3 1)))" "(count (filter (partial is-valid? 1) (opcode-sequence 3 1)))" "(filter (partial is-valid? 1) (opcode-sequence 3 1))" "(count (opcode-sequence 3 1))" "(count (filter (partial is-valid? 1) (opcode-sequence 3 1)))" "(count (filter (partial uses-vars-ok? 1) (opcode-sequence 3 1)))" "(count (filter \#(uses-vars-ok? 1 %) (opcode-sequence 3 1)))" "(uses-vars-ok? 1 '[\:bipush \:iload_3 \:ireturn])" "(uses-vars-ok? 1 '(\:bipush \:iload_3 \:ireturn))" "(count (opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 3 1))" "(prune-stats 6)" "(count (keys opcodes))" "(prune-stats 8)" "(count (opcode-sequence 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (opcode-sequence 6 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (expanded-numbered-opcode-sequence 1 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 4 1))" "(count (expanded-numbered-opcode-sequence 5 1))" "\#{1 2 3}" "(conj \#{1 2 3} 4)" "(doc contains)" "(doc? contains)" "doc contains" "(doc)" "(doc contains?)" "(doc some)" "(conj '() 1)" "(def tm {\:vars \#{} \:stack '()})" "tm" "(assoc tm \:stack (conj (\:stack tm) 0))" "(retains-influence? 1 '[\:iload_0 \:bipsuh \:\:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:\:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:ireturn])" "(some nil 0)" "(some \#{} 0)" "(doc some)" "(some 0 {})" "(some 0 {1})" "(some 0 \#{1})" "(some \#{0} \#{1})" "(some \#{0} \#{0})" "(some \#{0 1 2} \#{0})" "(some \#{0 1 2} \#{0 1 2})" "(retains-influence? 1 '[\:iload_0 \:bipush \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:iload_1 \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:istore_0 \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:istore_0 \:istore_1 \:ireturn])" "(assoc {} fred 1 ginger 2)" "(assoc {} \:fred 1 \:ginger 2)" "(retains-influence? 1 '[\:iload_0 \:bipush \:istore_0 \:istore_1 \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:istore_0 \:ireturn])" "(retains-influence? 1 '[\:istore_0 \:ireturn])" "(retains-influence? 1 '[\:bipush \:istore_0 \:ireturn])" "(retains-influence? 1 '[\:iload_1 \:istore_0 \:ireturn])" "(retains-influence? 1 '[\:iload_2 \:istore_0 \:ireturn])" "(retains-influence? 1 '[\:iload_2 \:istore_0 \:bipush \:ireturn])" "(retains-influence? 1 '[\:iload_2 \:istore_0 \:iload_0 \:ireturn])" "(range 0 2)" "(map \#(identity identity) (range 0 2))" "(map \#({identity identity}) (range 0 2))" "(map \#({% %}) (range 0 2))" "(map \#('{% %}) (range 0 2))" "(map \#({(identity %) 1}) (range 0 2))" "(map (into {}) (range 0 2))" "(map \#(into {} %) (range 0 2))" "(map \#(into {} % %) (range 0 2))" "(map \#(assoc {} % %) (range 0 2))" "into {} (map \#(assoc {} % %) (range 0 2))" "(into {} (map \#(assoc {} % %) (range 0 2)))" "(0 (into {} (map \#(assoc {} % %) (range 0 2))))" "(get (into {} (map \#(assoc {} % %) (range 0 2))) 0)" "(get (into {} (map \#(assoc {} % %) (range 0 2))) 1)" "(into {} (map \#(assoc {} % %) (range 0 4)))" "(retains-influence? 1 '[\:iload_2 \:istore_0 \:ireturn])" "(take 2 '(1 2 3 4 5))" "(into \#{} (take 2 '(1 2 3 4 5)))" "(doc conj)" "(retains-influence? 1 '[\:iload_2 \:istore_0 \:ireturn])" "(retains-influence? 1 '[\:iload_2 \:istore_0 \:idiv \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:idiv \:ireturn])" "(retains-influence? 1 '[\:bipush \:bipush \:idiv \:ireturn])" "(into \#{} (take 2 '(1 nil 3 4 5)))" "(into \#{} (filter (not nil?) (take 2 '(1 nil 3 4 5))))" "(into \#{} (filter (not(nil?)) (take 2 '(1 nil 3 4 5))))" "(into \#{} (filter (partial not(nil?)) (take 2 '(1 nil 3 4 5))))" "(into \#{} \#(partial (not (nil))) (take 2 '(1 nil 3 4 5)))" "(into \#{} \#(partial (not (nil?))) (take 2 '(1 nil 3 4 5)))" "(into \#{} \#(partial (not (nil? %))) (take 2 '(1 nil 3 4 5)))" "(into \#{} (filter \#(partial (not (nil? %))) (take 2 '(1 nil 3 4 5))))" "(into \#{} (filter \#(partial not nil? %) (take 2 '(1 nil 3 4 5))))" "(into \#{} (filter \#(partial (not (nil? %))) (take 2 '(1 nil 3 4 5))))" "(filter (not nil?) '(1 2 3 4 5))" "(filter (not(nil?)) '(1 2 3 4 5))" "(filter \#(not(nil? %)) '(1 2 3 4 5))" "(filter \#(not(nil? %)) '(1 nil 3 4 5))" "(retains-influence? 1 '[\:bipush \:bipush \:idiv \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:iload_1 \:idiv \:ireturn])" "(concat (take 2 (\#{1} \#{0})))" "(take 2 (\#{1} \#{0}))" "(take 2 '(\#{1} \#{0}))" "(take 2 (\#{1} \#{0}))" "(doc union)" "(doc combine)" "(doc set)" "(retains-influence? 1 '[\:iload_0 \:iload_1 \:idiv \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:iload_1 \:iload_2 \:idiv \:ireturn])" "(conj \#{2} \#{1})" "(doc union)" "(use 'clojure.set)" "(doc union)" "(union \#{2} \#{1})" "(retains-influence? 1 '[\:iload_0 \:iload_1 \:iload_2 \:idiv \:ireturn])" "(take 2 '(\#{1} \#{0}))" "(union (take 2 '(\#{1} \#{0})))" "(union (take 2 (\#{1} \#{0})))" "(take 2 (\#{1} \#{0}))" "(take 2 (seq (\#{1} \#{0})))" "(take 2 (seq \#{1} \#{0}))" "(seq (\#{0} \#{1}))" "[\#{0} \#{1}]" "[\#{0} \#{1} \#{2}]" "(take 2 [\#{0} \#{1} \#{2}])" "(apply union (take 2 [\#{0} \#{1} \#{2}]))" "(retains-influence? 1 '[\:iload_0 \:iload_1 \:iload_2 \:idiv \:ireturn])" "(retains-influence? 1\\n                    '[\:iload_1 \:iload_2 \:idiv \:istore_0 \:ireturn])" "(retains-influence? 1\\n                    '[\:iload_1 \:iload_2 \:idiv \:istore_0 \:iload_0 \:ireturn])" "(or nil 1)" "(or 1 nil)" "(retains-influence? 1\\n                    '[\:iload_1 \:iload_2 \:idiv \:istore_0 \:iload_0 \:ireturn])" "(get {0 \#{1 2}} 0)" "(or (get {0 \#{1 2}} 0) 0)" "(retains-influence? 1\\n                    '[\:iload_1 \:iload_2 \:idiv \:istore_0 \:iload_0 \:ireturn])" "(retains-influence? 1\\n                    '[\:iload_1 \:iload_2 \:idiv \:istore_0 \:iload_0 \:iload_0 \:ireturn])" "(set '(1 2))" "(set (range 0 2))" "(subset? (range 0 2) \#{0 1 2 3 4})" "(has-influence? 1 \#{0 2})" "(retains-influence? 1\\n                    '[\:iload_1 \:iload_2 \:idiv \:istore_0 \:iload_0 \:iload_0 \:ireturn])" "{\:vars {} \:stack (\#{1} \#{1} \#{2})}" "{\:vars {} \:stack (seq (\#{1} \#{1} \#{2}))}" "\#{1}" "(seq (\#{1} \#{1} \#{2}))" "[\#{1} \#{1}]" "(seq \#{1} \#{2})" "(seq (\#{1} \#{2}))" "(seq (\#{1} \#{2} \#{3}))" "(list (\#{1} \#{2} \#{3}))" "'(\#{1} \#{2} \#{3})" "(first '(\#{1} \#{2} \#{3}))" "(subset (first '(\#{1} \#{2} \#{3})) \#{1 2 3})" "(subset? (first '(\#{1} \#{2} \#{3})) \#{1 2 3})" "(iterate 2 pop '(1 2 3 4))" "(take 2 (iterate pop '(1 2 3 4)))" "(nthrest '(1 2 3 4) 2)" "(first '(\#{1} \#{2}))" "(second '(\#{1} \#{2}))" "(nthrest '(\#{1} \#{2}) 2)" "(concat (first '(\#{1} \#{2})) (second '(\#{1} \#{2})))" "(conj (first '(\#{1} \#{2})) (second '(\#{1} \#{2})))" "(cons (first '(\#{1} \#{2})) (second '(\#{1} \#{2})))" "(first '(\#{1} \#{2}))" "(second '(\#{1} \#{2}))" "(conj (first '(\#{1} \#{2})) (first '(\#{1} \#{2})))" "(cons (first '(\#{1} \#{2})) (first '(\#{1} \#{2})))" "(conj (seq((first '(\#{1} \#{2})))))" "(conj (seq((first '(\#{1} \#{2})))) (seq((first '(\#{1} \#{2})))))" "(conj (seq(first '(\#{1} \#{2}))) (seq(first '(\#{1} \#{2}))))" "(concat (seq(first '(\#{1} \#{2}))) (seq(first '(\#{1} \#{2}))))" "(conj (first '(\#{1} \#{2})) (seq(first '(\#{1} \#{2}))))" "(reverse (take 2 '(\#{1} \#{2})))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 4 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 4 1))" "(count (expanded-numbered-opcode-sequence 5 1))" "(count (opcode-sequence 5 1))" "(count (opcode-sequence 6 1))" "(count (opcode-sequence 7 1))" "(time (doall (superoptimise-pmap 4 class-name method-name method-signature eq-tests-filter)))" "(count (expanded-numbered-opcode-sequence 4 1))" "(use 'org.tomhume.so.Opcodes)" "(count (expanded-numbered-opcode-sequence 4 1))" "(time (count (expanded-numbered-opcode-sequence 4 1)))" "1" "(+ 1 1)" "1" "(float 353383/3518743761)" "1" "(time (count (expanded-numbered-opcode-sequence 4 1)))" "(use 'org.tomhume.so.Opcodes)" "(time (count (expanded-numbered-opcode-sequence 4 1)))" "1" "(time (count (opcode-sequence 4 1)))" "(time (count (expanded-numbered-opcode-sequence 4 1)))" "(mod 1000 10)" "(mod 6 3)" "(mod 6 4)" "(test-recreate-cl-every 1 1)" "1" "(test-recreate-cl-every 1 1)" "(test-recreate-cl-every 1000 1)" "(test-recreate-cl-every 50000 1)" "(time (test-recreate-cl-every 100000 1))" "(time (test-recreate-cl-every 100000 100000))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'org.tomhume.so.ClassLoaderSpeed)))" "(time (test-recreate-cl-every 100000 100000))" "(time (test-recreate-cl-every 100000 1))" "(time (test-recreate-cl-every 100000 50000))" "(time (test-recreate-cl-every 200000 50000))" "(time (test-recreate-cl-every 200000 1))" "(time (test-recreate-cl-every-hold-asm-refs 100000 50000))" "(time (test-recreate-cl-every-hold-asm-refs 100000 1))" "(time (test-recreate-cl-every-hold-asm-refs 10 1))" "(time\\n  (test-recreate-cl-every-hold-asm-refs 100000 50000))" "(time\\n  (test-recreate-cl-every 100000 50000))" "(time\\n  (test-recreate-cl-every-hold-asm-refs 100000 50000))" "(init-state 1)" "(into {} (map \#(% 0) (range 0 2)))" "(into {} (map \#([% 0]) (range 0 2)))" "(map \#([% 0]) (range 0 2))" "(map \#(vec(% 0)) (range 0 2))" "(map \#('(% 0)) (range 0 2))" "(map \#('[% 0]) (range 0 2))" "(range 0 2)" "(map \#(identity %) (range 0 2))" "(map \#([(identity %) 0]) (range 0 2))" "[1 1]" "[(identity 1) 1]" "(map \#('[(identity %) 0]) (range 0 2))" "(apply assoc {} (interleave (range 0 2) 0))" "(apply assoc {} (interleave (range 0 2) (range 0 2)))" "(apply assoc {} (interleave (range 0 2) (range 0 0)))" "(apply assoc {} (interleave (range 0 2) (repeat 0))\\n       )" "(apply assoc {} (interleave (range 0 2) (repeat 3)))" "(init-state 3)" "(\:vars (init-state 3))" "(2 (\:vars (init-state 3)))" "(get (\:vars (init-state 3)) 2)" "(let [sm (init-state 3)]\\n  (assoc sm \:max-var (inc (\:max-var sm)))\\n  )" "(let [sm (init-state 3)]\\n  (assoc sm \:max-var (inc (\:max-var sm))))" "(let [sm (init-state 3)]\\n  (assoc sm \:max-var 1))" "(let [sm (init-state 3)]\\n  (assoc sm \:max-var (inc (\:max-var sm))))" "(cons '() 1)" "(conj '() 1)" "(conj '(1 2 3) 1)" "(conj '(1 2 3) 1 2)" "(add-state (init-state 1) \:bipush)" "(cons \:a \:b)" "(seq \:a \:b)" "(seq (\:a \:b))" "(seq '(\:a \:b))" "(add-state (init-state 1) \:bipush)" "(seq [\:a \:b])" "(add-state (init-state 1) \:bipush)" "(add-state (add-state (init-state 1) \:bipush) \:bipush)" "(add-state (init-state 1) \:bipush)" "(add-state (add-state (init-state 1) \:bipush) \:bipush)" "(add-state (add-state (init-state 1) \:bipush) \:dup)" "(range 1)" "(add-state (add-state (init-state 1) \:bipush) \:dup)" "'(1 2 3)" "(def tl '(1 2 3 4 5))" "tl" "(concat (second tl) (first tl) (nthrest tl 2))" "(concat (second tl) (first tl) (nthrest 2 tl))" "(second tl)" "(first tl)" "(nthrest tl 3)" "(concat (seq ((second tl) (first tl))) (nthrest 2 tl))" "(concat (cons ((second tl) (first tl))) (nthrest 2 tl))" "(cons 1 2)" "(conj 1 2)" "(into '() 1 2)" "(into '() 1)" "(concat (list ((second tl) (first tl))) (nthrest 2 tl))" "(list 1 2)" "(concat (list (second tl) (first tl)) (nthrest 2 tl))" "(list (second tl) (first tl))" "(concat (list (second tl) (first tl)) '(1 2 3))" "(concat (list (second tl) (first tl)) (nthrest 2 tl))" "(concat (list (second tl) (first tl)) (nthrest tl 2))" "(add-state\\n        '{\:stack ([\:constant 1] [\:constant 2] [\:constant 3]), \:max-var 0, \:max-const 4, \:max-calc 0, \:vars {0 0}}\\n        \:iadd)" "(doc \:fred)" "(name \:fred)" "(keyword \\"fred\\")" "(map \#(keyword (str \\"arg-\\" %)) (range 0 3))" "(into {} (map \#(keyword (str \\"arg-\\" %)) (range 0 3)))" "(into {} (map \#([keyword (str \\"arg-\\" %) 0]) (range 0 3)))" "(into {} (map \#(list(keyword (str \\"arg-\\" %) 0)) (range 0 3)))" "(into {} (map \#(list((keyword (str \\"arg-\\" %)) 0)) (range 0 3)))" "(into {} (map \#((keyword (str \\"arg-\\" %)) 0)) (range 0 3))" "(into {}\\n      (map \#((keyword (str \\"arg-\\" %)) 0)\\n           (range 0 3)))" "(into {}\\n      (map \#([(keyword (str \\"arg-\\" %)) 0])\\n           (range 0 3)))" "(map \#(identity %) (range 3))" "(apply hash-map (map \#(identity %) (range 3)))" "(apply hash-map (map \#(list((identity %)(identity %)) (range 3))))" "(apply hash-map\\n       (map \#(list((identity %)(identity %))) (range 3)))" "(apply hash-map\\n       (map \#(list( (identity %) (identity %))) (range 3)))" "(def in '(0 1 2 3 4))" "(map \#(keyword(str \\"arg-\\" %)) in)" "(interleave \#(keyword(str \\"arg-\\" %)) in)" "(interleave (map \#(keyword(str \\"arg-\\" %)) in) in)" "(interleave (map \#(keyword(str \\"arg-\\" %)) in) (repeat 0))" "(interleave (map \#(keyword(str \\"arg-\\" %)) (range 3)) (repeat 0))" "(into {} (interleave (map \#(keyword(str \\"arg-\\" %)) (range 3)) (repeat 0)))" "(hash-map (interleave (map \#(keyword(str \\"arg-\\" %)) (range 3)) (repeat 0)))" "(into hash-map (interleave (map \#(keyword(str \\"arg-\\" %)) (range 3)) (repeat 0)))" "(into {} '(1 2 3 4))" "(into {} '[1 2 3 4])" "(hash-map '(1 2 3 4))" "(apply hash-map '(1 2 3 4))" "(init-state 4)" "(str \\"arg-1\\" 1)" "(init-state 4)" "(init-state 1)" "(def m {0 [\:arg-0] 1 nil 2 nil 3 nil})" "m" "(def c 12)" "(map \#(identity %) (keys m))" "(map \#(% m) (keys m))" "(map \#(get m %) (keys m))" "(let [i (atom 0)]\\n  (map \#([m (swap\! i inc)]) (keys m)))" "(let [i (atom 0)]\\n  (map \#([% (swap\! i inc)]) (keys m)))" "(let [i (atom 0)]\\n  (map \#([(identity %) (swap\! i inc)]) (keys m)))" "(let [i (atom 0)]\\n  (map \#([identity %]) (keys m)))" "(let [i (atom 0)]\\n  (map \#(list (identity %)) (keys m)))" "(let [i (atom 0)]\\n  (map \#(list (identity %) (swap\! i inc)) (keys m)))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (map \#(list (identity %) (swap\! i inc)) (keys m))))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (map \#([(identity %) (swap\! i inc)]) (keys m))))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (map \#(list (identity %) (swap\! i inc)) (keys m))))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (into {} (map \#(list (identity %) (swap\! i inc)) (keys m)))))" "(let [i (atom 0)]\\n            (into {} (map \#(list (identity %) (swap\! i inc)) (keys m))))" "(let [i (atom 0)]\\n           (map \#(list (identity %) (swap\! i inc)) (keys m)))" "(let [i (atom 0)]\\n           (map \#({(identity %) (swap\! i inc)}) (keys m)))" "(let [i (atom 0)]\\n           (map \#(into {} list ((identity %) (swap\! i inc))) (keys m)))" "(let [i (atom 0)]\\n           (apply hash-map (interleave (repeat (swap\! i inc)) (keys m))))" "(let [i (atom 0)]\\n           (apply hash-map (interleave (iterate (swap\! i inc)) (keys m))))" "(let [i (atom 0)]\\n           (apply hash-map (repeatedly (iterate (swap\! i inc)) (keys m))))" "(let [i (atom 0)]\\n           (apply hash-map (interleave (repeatedly (swap\! i inc)) (keys m))))" "(let [i (atom 0)](take 5 (repeatedly (swap\! i inc))))" "(let [i (atom 0)]\\n         (into {} (map \#(list (identity %) (swap\! i inc)) (keys m))))" "(let [i (atom 0)]\\n         (into {} (map \#(list ((identity %) (swap\! i inc))) (keys m))))" "(let [i (atom 0)]\\n        (map \#(list ((identity %) (swap\! i inc))) (keys m)))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (into {} (map \#(list (identity %) (swap\! i inc)) (keys m)))))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (map \#([(identity %) (swap\! i inc)]) (keys m))))" "(let [i (atom 0)]\\n  (map \#(list (identity %) (swap\! i inc)) (keys m)))" "(let [i (atom 0)]\\n  (interleave (repeatedly (swap\! i inc)) (keys m)))" "(let [i (atom 0)]\\n  (interleave (repeatedly (swap\! i inc))\\n              (keys m)))" "(let [i (atom 0)]\\n  (swap\! i inc))" "(let [i (atom 0)]\\n  (repeatedly (swap\! i inc)))" "(let [i (atom 0)]\\n  (repeatedly \#(swap\! i inc)))" "(let [i (atom 0)]\\n  (take 10 (repeatedly \#(swap\! i inc))))" "(let [i (atom 0)]\\n  (interleave (repeatedly \#(swap\! i inc))\\n              (keys m)))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (interleave (repeatedly \#(swap\! i inc))\\n              (keys m))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (repeatedly \#(swap\! i inc))\\n              (keys m))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (keys m)\\n         (interleave (repeatedly \#(swap\! i inc)))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         \\n         (interleave (keys m) (repeatedly \#(swap\! i inc)))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(swap\! i inc)))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#([\:var (swap\! i inc)])))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#('[\:var (swap\! i inc)])))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(vec (\:var (swap\! i inc)))))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(vec ('\:var (swap\! i inc)))))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(\:var (swap\! i inc))))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#([\:var (swap\! i inc)])))))" "[\:var 1]" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#[\:var (swap\! i inc)]))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(vec {\:var (swap\! i inc)})))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(vec \:var (swap\! i inc))))))" "(vec \:var 1)" "(vec (\:var 1))" "(vec '(\:var 1))" "(vec '(\:var 1) '(\:var 2))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#([\:var (swap\! i inc)])))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(list \:var (swap\! i inc))))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(vec \:var (swap\! i inc))))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(list \:var (swap\! i inc))))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(vector \:var (swap\! i inc))))))" "(prune-stats 6)" "(use 'org.tomhume.so.PruningTests)" "(prune-stats 6)" "(prune-stats 8)" "(count (expanded-numbered-opcode-sequences 2 1))" "(use 'org.tomhume.so.Opcodes)" "(count (expanded-numbered-opcode-sequences 2 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count\\n  (expanded-numbered opcode-sequence 2 1))" "(count\\n  (expanded-numbered-opcode-sequence 2 1))" "(count\\n  (expanded-numbered-opcode-sequence 3 1))" "(count\\n  (expanded-numbered-opcode-sequence 4 1))" "(doc swap\!)" "1" "(mod 5000 1000)" "(doc do)" "1" "2" "3" "1" "classloader" "(use 'Main.Bytecode)" "classloader" "@classloader" "instantiate-classloader" "(instantiate-classloader)" "(instantiate-classloader 1)" "1" "(doc swap\!)" "(doc set\!)" "(doc swap\!)" "(init-classloader)" "(instantiate-classloader)" "(instantiate-classloader 1)" "(init-classloader)" "classloader" "@classloader" ".defineClass" "(is (\= true (no-redundancy? 1 '[\:iload_0 \:ireturn])))" "(use 'clojure.test)" "(is (\= true (no-redundancy? 1 '[\:iload_0 \:ireturn])))" "(use '[Filters.RedundancyFilter])" "(is (\= true (no-redundancy? 1 '[\:iload_0 \:ireturn])))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'Main.Bytecode)))" "(def classloader (atom (new clojure.lang.DynamicClassLoader)))" "(swap\! classloader instantiate-classloader)" "(use 'Main.Bytecode)" "(swap\! classloader instantiate-classloader)" "classloader" "1" "(time (count (expanded-numbered-opcode-sequence 5 1)))" "(use 'Main.Opcodes)" "(time (count (expanded-numbered-opcode-sequence 5 1)))" "(time-limited 1000 (sleep 100000))" "(use 'Util.TestMap)" "(time-limited 1000 (sleep 100000))" "(time-limited 1000 (Thread/sleep 100000))" "(time-limited 1000 (Thread/sleep 100))" "(time-limited 1000 (Thread/sleep 1001))" "(time-limited 1000 true)" "(expand-arg 1 3 \:branch-dest)" "(use 'Main.Opcodes)" "(expand-arg 1 3 \:branch-dest)" "(expand-arg 1 2 \:branch-dest)" "(expand-arg 1 1 2 \:branch-dest)" "(expand-arg 1 1 3 \:branch-dest)" "(expand-arg 0 1 3 \:branch-dest)" "(expand-arg 1 1 3 \:branch-dest)" "(expand-arg 2 1 3 \:branch-dest)" "(expand-arg 3 1 3 \:branch-dest)" "(expanded-numbered-opcode-sequence 2 1)" "(expanded-numbered-opcode-sequence 3 1)" "(expanded-numbered-opcode-sequence 2 1)" "(expanded-numbered-opcode-sequence 3 1)" "(expand-arg 1 1 3 \:branch-dest)" "(expand-opcodes 1 '[\:iconst_4 \:goto \:ireturn])" "(count '[\:iconst_4 \:goto \:ireturn])" "(expand-arg 0 1 3 \:branch-dest)" "(expand-opcodes 1 '[\:iconst_4 \:goto \:ireturn])" "(expand-arg 1 3 2 \:branch-dest)" "(count '[\:iconst_4 \:goto \:ireturn])" "(expand-arg 1 3 2 \:branch-dest)" "(expand-opcodes 1 '[\:iconst_4 \:goto \:ireturn])" "(expand-opcodes 1 '[\:iconst_4 \:goto])" "(expand-opcodes 1 '[\:iconst_4 \:goto \:ireturn])" "(expand-opcodes 1 '[\:iconst_4 \:iconst_0 \:goto])" "(expand-arg 1 5 1 \:local-var)" "(expanded-numbered-opcode-sequence 3 1)" "(expanded-numbered-opcode-sequence 4 1)" "(take 10000 (expanded-numbered-opcode-sequence 4 1))" "(take 1 (expanded-numbered-opcode-sequence 4 1))" "1" "(is (\= '() (update-labelling '(\:iload_0 \:goto -1 \:ireturn) \:label_0 1 -1)))" "(update-labelling '(\:iload_0 \:goto -1 \:ireturn) \:label_0 1 -1)" "(use 'Main.Bytecode)" "(update-labelling '(\:iload_0 \:goto -1 \:ireturn) \:label_0 1 -1)" "(update-labelling '(\:iload_0 \:goto -1 \:ireturn) \:label_0 1 1)" "(update-labelling '(\:a 1 \:b \:c \:d \:e) \:1 0 2)" "(insert-at '(\:a 1 \:b \:c \:d \:e) \:1 0 2)" "(< 2 1)" "(< 1 2)" "(insert-at '(\:a 1 \:b \:c \:d \:e) \:1 0 2)" "(name \:label_0)" "(re-find \#\\"^label\\" \\"label-1\\")" "(re-find \#\\"^label\\" \\"fred\\")" "(re-find \#\\"^label\\" \\"this is a label\\")" "(seq (re-find \#\\"^label\\" \\"this is a label\\"))" "(seq (re-find \#\\"^label\\" \\"label-\\"))" "(re-find \#\\"^label\\" \\"label-\\")" "(if (re-find \#\\"^label\\" \\"label-\\") true false)" "(if (re-find \#\\"^label\\" \\"a label-\\") true false)" "(distinct (filter \#(re-matches \#\\"^label_\\") '(\:one \:two \:label_1 \:three \:label_2 \:four \:label_1)))" "(distinct (filter \#(re-matches \#\\"^label_\\" %) '(\:one \:two \:label_1 \:three \:label_2 \:four \:label_1)))" "(distinct (filter \#(re-matches \#\\"^label_\\" (name %)) '(\:one \:two \:label_1 \:three \:label_2 \:four \:label_1)))" "(filter \#(re-matches \#\\"^label_\\" (name %)) '(\:one \:two \:label_1 \:three \:label_2 \:four \:label_1))" "(filter \#(re-matches \#\\"label_\\" (name %)) '(\:one \:two \:label_1 \:three \:label_2 \:four \:label_1))" "(filter \#(re-matches \#\\"label_\\" (name %)) '[\:one \:two \:label_1 \:three \:label_2 \:four \:label_1])" "(filter \#(re-matches \#\\"^label_\\" (name %)) '[\:one \:two \:label_1 \:three \:label_2 \:four \:label_1])" "(re-matches \#\\"^label_\\" (name \:label_1))" "(re-matches \#\\"label\\" (name \:label_1))" "(name \:kabel_1)" "(re-matches \#\\"label\\" (name \:label_1))" "(filter \#(re-find \#\\"^label_\\" (name %)) '[\:one \:two \:label_1 \:three \:label_2 \:four \:label_1])" "(distinct (filter \#(re-find \#\\"^label_\\" (name %)) '[\:one \:two \:label_1 \:three \:label_2 \:four \:label_1]))" "(map \#{% (new LabelNode)} (distinct\\n  (filter \#(re-find \#\\"^label_\\" (name %))\\n          '[\:one \:two \:label_1 \:three \:label_2 \:four \:label_1])))" "(import '(org.objectweb.asm.tree  AbstractInsnNode VarInsnNode InsnNode IincInsnNode IntInsnNode ClassNode MethodNode InsnList LabelNode))" "(map \#{% (new LabelNode)} (distinct\\n  (filter \#(re-find \#\\"^label_\\" (name %))\\n          '[\:one \:two \:label_1 \:three \:label_2 \:four \:label_1])))" "(map \#(% (new LabelNode)) (distinct\\n  (filter \#(re-find \#\\"^label_\\" (name %))\\n          '[\:one \:two \:label_1 \:three \:label_2 \:four \:label_1])))" "(distinct\\n  (filter \#(re-find \#\\"^label_\\" (name %))\\n          '[\:one \:two \:label_1 \:three \:label_2 \:four \:label_1]))" "(map \#(% (new LabelNode)) (distinct\\n  (filter \#(re-find \#\\"^label_\\" (name %))\\n          '[\:one \:two \:label_1 \:three \:label_2 \:four \:label_1])))" "(map \#(assoc % (new LabelNode)) (distinct\\n  (filter \#(re-find \#\\"^label_\\" (name %))\\n          '[\:one \:two \:label_1 \:three \:label_2 \:four \:label_1])))" "(map \#(assoc {} % (new LabelNode)) (distinct\\n  (filter \#(re-find \#\\"^label_\\" (name %))\\n          '[\:one \:two \:label_1 \:three \:label_2 \:four \:label_1])))" "(into {} (map \#(assoc {} % (new LabelNode)) (distinct\\n  (filter \#(re-find \#\\"^label_\\" (name %))\\n          '[\:one \:two \:label_1 \:three \:label_2 \:four \:label_1]))))" "(get-class-bytes '(\:iload_0 \:ireturn) \\"Identity\\" \\"id\\" \\"I(I)\\")" "(get-class-bytes '(\:iload_0 \:ireturn) \\"Identity\\" \\"identity\\" \\"I(I)\\")" "(get-class-bytes '(\:iload_0 \:ireturn) \\"Identity\\" \\"identity\\" \\"(I)I\\")" "(get-instructions '(\:iload_0 \:ireturn))" "(.iterator \\n  (get-instructions '(\:iload_0 \:ireturn)))" "(iterator-seq (.iterator \\n  (get-instructions '(\:iload_0 \:ireturn))))" "(iterator-seq (.iterator \\n  (get-instructions '(\:iload_0 \:goto -1 \:ireturn))))" "(expanded-numbered-opcode-sequence 3 1)" "(use 'Main.Superoptimise)" "(expanded-numbered-opcode-sequence 3 1)" "(use 'Main.Opcodes)" "(expanded-numbered-opcode-sequence 3 1)" "(opcode-sequence 3 1)" "(use 'Main.Opcodes)" "(opcode-sequence 3 1)" "(opcode-sequence 2 1)" "(name 0)" "(type 0)" "(type \:name)" "(class \:name)" "(use 'Main.Bytecode)" "(add-opcode-and-args (new InsnList) '(\:goto {})\\n                     )" "(import '(org.objectweb.asm.tree  AbstractInsnNode VarInsnNode InsnNode IincInsnNode JumpInsnNode IntInsnNode ClassNode MethodNode InsnList LabelNode))" "(add-opcode-and-args (new InsnList) '(\:goto {})\\n                     )" "(add-opcode-and-args\\n  (new InsnList)\\n  '(\:goto)\\n  {})" "(is-a-label? \:goto)" "(if (is-a-label? \:goto)\\n  0\\n  (count ((opcodes op) \:args)))" "(use 'Main.Global)" "(if (is-a-label? \:goto)\\n  0\\n  (count ((opcodes op) \:args)))" "(if (is-a-label? \:goto)\\n  0\\n  (count ((opcodes \:goto) \:args)))" "(is-jump? \:goto)" "((opcodes \:goto) \:opcode)" "(add-opcode-and-args\\n  (new InsnList)\\n  '(\:goto)\\n  {})" "(add-opcode-and-args\\n  (new InsnList)\\n  '(\:goto \:label_0)\\n  {\:label_0 (new LabelNode)})" "(add-opcode-and-args\\n  (new InsnList)\\n  '(\:goto)\\n  {})" "(get-instructions '(\:iload_0 \:goto 1 \:ireturn))" "(add-labels '(\:iload_0 \:goto 1 \:ireturn))" "(make-labels-map '(\:iload_0 \:goto \:label_0 \:label_0 \:ireturn))" "(filter is-a-label? '(\:iload_0 \:goto \:label_0 \:label_0 \:ireturn))" "(\= \\"clojure.lang.Keyword\\" (type \:iload_0))" "(type \:iload_0)" "(\= clojure.lang.Keyword (type \:iload_0))" "(filter is-a-label? '(\:iload_0 \:goto \:label_0 \:label_0 \:ireturn))" "(get-instructions '(\:bipush 0 \:goto -2 \:ireturn))" "(iterator-seq(.iterator \\n     (get-instructions '(\:bipush 0 \:goto -2 \:ireturn))))" "(iterator-seq(.iterator \\n     (get-instructions '(\:bipush 1 \:goto -1 \:ireturn))))" "(get-instructions '(\:bipush 1 \:goto -1 \:ireturn))" "(add-labels '(\:bipush 1 \:goto -1 \:ireturn))"]
eclipse.preferences.version=1
