cmdhistory=["(use 'Opcodes)" "(opcode-sequence 2)" "1" "2" "(opcode-sequence 4)" "(mapcat identity (((\:istore 0 \:istore 0) (\:istore 0 \:istore 1) (\:istore 1 \:istore 0) (\:istore 1 \:istore 1)) ((\:ixor \:ireturn))))" "(mapcat identity '(((\:istore 0 \:istore 0) (\:istore 0 \:istore 1) (\:istore 1 \:istore 0) (\:istore 1 \:istore 1)) ((\:ixor \:ireturn))))" "(mapcat identity '((\:istore 0 \:istore 0) (\:istore 0 \:istore 1) (\:istore 1 \:istore 0) (\:istore 1 \:istore 1)) ((\:ixor \:ireturn)))" "(mapcat identity '(((a b) (c d))((e f))))" "(mapcat identity '((a b) (c d))((e f)))" "1" "(nthrest '(\:a \:b \:c \:d \:e) 2)" "(nthrest 2 '(\:istore \:arg \:ireturn))" "(use org.tomhume.so.Opcodes)" "(use 'org.tomhume.so.Opcodes)" "(opcodes \:pop)" "((opcodes \:pop) \:opcode)" "(new InsnNode 87)" "(new InsnNode ((opcodes \:pop) \:opcode))" "(. (new InsnList) add (new InsnNode ((opcodes \:pop) \:opcode)))" "(next '(1 2 3))" "\:arg" "(\:arg)" "(first '[ 1 2 3])" "(second '[ 1 2 3])" "(nthrest '(1 2 3 4) 0)" "(opcodes \:pop)" "(((opcodes \:istore) \:args) count)" "(opcodes \:istore)" "((opcodes \:istore) \:args)" "(count ((opcodes \:istore) \:args))" "(ns some.Example\\n  (\:gen-class))\\n\\n(defn -toString\\n  [this]\\n  \\"Hello, World\!\\")" "(some.Example.)" "(-toString (some.Example.))" "(use 'some.Example)" "('some.Example/-toString)" "(-toString (some.Example.))" "(gen-and-load-class 'foo.MyClass\\n   \:methods [['mymethod [String] String]\\n             ['finalize [] Void/TYPE]])" "(ns test.test\\n    (\:gen-class))\\n\\n(defn -main\\n    [gre]\\n    (println (str \\"Hello \\" gre)))" "(test.test)" "(compile 'test.test)" "(test.test.)" "(ns some.Example\\n  (\:gen-class))\\n\\n(defn -toString\\n  [this]\\n  \\"Hello, World\!\\")" "(-toString (some.Example.))" "(ns org.tomhume.so.Bytecode)" "(reflect ClassLoader)" "(use 'clojure.reflect)" "(reflect ClassLoader)" "(reflect ClassLoader \:members)" "(def test-proxy (proxy [Object] [] (test-method [] (println \\"a\\"))))" "text-proxy" "test-proxy" "(test-method test-proxy)" "(test-proxy test-method)" "(.test-method test-proxy)" "(def test-proxy (proxy [Object] [] (testMethod [] (println \\"a\\"))))" "(.testMethod test-proxy)" "(type test-proxy)" "(do-reflect test-proxy)" "(reflect test-proxy)" "(class test-proxy)" "(def test-proxy (proxy [Object] [] (toString [] (println \\"a\\"))))" "(.toString test-proxy)" "(def test-proxy (proxy [ClassLoader] [] (defineClass [name bytes offset len] (proxy-super name bytes offset len))))" "(.defineClass test-proxy \\"a\\" \\"b\\" 0 1)" "(def test-proxy (proxy [ClassLoader] [] (defineClass [name bytes offset len] (proxy-super defineClass name bytes offset len))))" "(.defineClass test-proxy \\"a\\" \\"b\\" 0 1)" "(reflect test-proxy)" "(use 'clojure.reflect)" "(reflect cg)" "(.dummy cg)" "(-dummy cg)" "(.dummy cg)" "(class cg)" "(.dummy cg)" "(-dummy cg)" "(.dummy cg a)" "(.dummy cg 'a)" "(.dummy cg)" "(-dummy cg)" "cg" "(class cg)" "(use 'clojure.reflect)" "(reflect cg)" "(.dummy cg)" "(-dummy cg)" "(reload-class 'a l)" "(reload-class 'a 'l)" "(use 'clojure.reflect)" "(reflect f)" "(reflect f1)" "(reflect f2)" "(reflect f1)" "(reflect f2)" "(.identity f1 1)" "f1" "(class f1)" "(def method (.getDeclaredMethod f1 \\"identity\\" Integer/TYPE))" "(.getDeclaredMethod f1 \\"identity\\" 1)" "(reflect f1)" "(type f1)" "(.identity f1)" "(.identity f1 1)" "(f1/identity 1)" "(IdentityTest1/identity 1)" "(IdentityTest1/identity)" "(type f1)" "(import IdentityTest1)" "(class f1)" "(reflect f1)" "(identity f1)" "(id f1)" "(f1 id)" "(reflect f1)" "(reflect f2)" "(id_two f2)" "(.id_two f2)" "(.idTwo IdentityTwo 1)" "(.idTwo IdentityTest-2 1)" "(IdentityTestTwo/idTwo 1)" "(IdentityTest-2)" "(IdentityTest-2/idTwo 2)" "(IdentityTest-2/id_two 2)" "(IdentityTest-1/id_two 2)" "(IdentityTest-1/identity 2)" "(f1/identity 2)" "(type f1)" "(. ~f1)" "(. ~f1 identity 1)" "(import 'clojure.lang.Reflector)" "(import clojure.lang.Reflector)" "(import 'clojure.lang.Reflector)" "(Reflector/invokeStaticMethod Integer \\"parseInt\\" (into-array [\\"1\\"]))" "(defmacro static-call [var method & args]\\n  `(-> (.getName ~var)\\n       (symbol ~(str method))\\n       (list ~@args)\\n       eval))" "(static-call \\"IdentityTest-2\\" \\"identity\\" 1)" "(static-call f1 'identity 1)" "(static-call f1 \\n             \\"identity\\" 1)" "opcodes" "1" "(def f1 (get-class '(\:iload 0 \:ireturn) \\"IdentityTest-1\\" \\"identity\\" \\"(I)I\\"))" "type f1" "(type f1)" "(def f1 (get-class '(\:iload 0 \:ireturn) \\"IdentityTest-1\\" \\"identity\\" \\"(I)I\\"))" "(mapcat identity (map expand-opcodes (opcode-sequence 2)))" "(map \#(println (\:code %))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2))))" "(map \#(println (% \:code))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2))))" "(map \#(println %)\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2))))" "(count (map \#(println %)\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(count (map \#(println (first %))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(count (map \#(println (\:code %))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(count (map \#(println (\:code %))\\n     (first (mapcat identity (map expand-opcodes (opcode-sequence 2))))))" "(count (map \#(println %)\\n     (first (mapcat identity (map expand-opcodes (opcode-sequence 2))))))" "(first (map \#(println %)\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(first (map expand-opcodes (opcode-sequence 2)))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'org.tomhume.so.Opcodes)))" "(first (map \#(println %)\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(first (map \#(println (\:code %))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(let [seqnum 0]\\n  (4 seqnum))" "(System/gc)" "\\n(defn a \\"\\" [] (try (do (1/0) true) (catch Exception e false)))" "(defn a \\"\\" [b] (try (do (1/b) true) (catch Exception e false)))" "(defn a \\"\\" [b] (try (1/b) (catch Exception e 999))\\n  )" "(defn a \\"\\" [b] (try (/ 1 b) (catch Exception e 999)))" "(a 1)" "(a 0)" "(defn a \\"\\" [b] (try (> 0 (/ 1 b)) (catch Exception e 999)))" "(a 1)" "(a 0.1)" "(defn a \\"\\" [b] (try (> (/ 1 b) 0) (catch Exception e 999)))" "(a 1)" "(a 0.1)" "(a 0)" "(defn a \\"\\" [b] (try (> (/ 1 b) 0) (catch Exception e false)))" "(a 0)" "(def newInt (new Integer))" "(def newInt (new Integer 3))" "newInt" "(static-call newInt \\"parseInt\\" \\"1\\")" "(static-call (class newInt) \\"parseInt\\" \\"1\\")" "(static-call (class newInt) \\"parseInt\\" \\"123\\")" "(class meth-name)" "(def meth-name \\"parseInt\\")" "(static-call (class newInt meth-name \\"123\\"))" "(static-call (class newInt) meth-name \\"123\\")" "(symbol meth-name)" "(defmacro static-call [var method & args]\\n     `(-> (.getName ~var)\\n          (symbol ~method)\\n          (list ~@args)\\n          eval))" "(ns-unmap 'org.tomhume.so.Bytecode static-call)" "(ns-unmap 'org.tomhume.so.Bytecode 'static-call)" "(defmacro static-call [var method & args]\\n        `(-> (.getName ~var)\\n             (symbol ~method)\\n             (list ~@args)\\n             eval))" "(static-call (class newInt) meth-name \\"123\\")" "(import 'clojure.lang.Reflector)" "(Reflector/invokeStaticMethod Integer meth-name (into-array [\\"1\\"]))" "(map expand-opcodes (opcode-sequence 2))" "(map-indexed expand-opcodes (opcode-sequence 2))" "(expanded-numbered-opcode-sequence 2)" "(range 0 0)"]
eclipse.preferences.version=1
