cmdhistory=["(def newInt (new Integer))" "(def newInt (new Integer 3))" "newInt" "(static-call newInt \\"parseInt\\" \\"1\\")" "(static-call (class newInt) \\"parseInt\\" \\"1\\")" "(static-call (class newInt) \\"parseInt\\" \\"123\\")" "(class meth-name)" "(def meth-name \\"parseInt\\")" "(static-call (class newInt meth-name \\"123\\"))" "(static-call (class newInt) meth-name \\"123\\")" "(symbol meth-name)" "(defmacro static-call [var method & args]\\n     `(-> (.getName ~var)\\n          (symbol ~method)\\n          (list ~@args)\\n          eval))" "(ns-unmap 'org.tomhume.so.Bytecode static-call)" "(ns-unmap 'org.tomhume.so.Bytecode 'static-call)" "(defmacro static-call [var method & args]\\n        `(-> (.getName ~var)\\n             (symbol ~method)\\n             (list ~@args)\\n             eval))" "(static-call (class newInt) meth-name \\"123\\")" "(import 'clojure.lang.Reflector)" "(Reflector/invokeStaticMethod Integer meth-name (into-array [\\"1\\"]))" "(map expand-opcodes (opcode-sequence 2))" "(map-indexed expand-opcodes (opcode-sequence 2))" "(expanded-numbered-opcode-sequence 2)" "(range 0 0)" "1" "(expanded-numbered-opcode-sequence 3 1)" "1" "(count (expanded-numbered-opcode-sequence 3 1))" "(mod 2 3)" "(mod 100 10)" "(mod 101 10)" "(let [num 1001] (doall (if (\= (0 (mod num 1000))) (println num))))" "(let [num 1001] (if (\= (0 (mod num 1000))) (println num)))" "(if (\= 0 (mod num 1000)) (println \\"hello\\"))" "(if (\= 0 (mod 1001 1000)) (println \\"hello\\"))" "(if (\= 0 (mod 2000 1000)) (println \\"hello\\"))" "(ns-publics 'org.tomhume.so.Main)" "(ns-publics 'org.tomhume.so.IdentitySO)" "(ns-publics 'org.tomhume.so.LoadManyClasses)" "1" "(count (expanded-numbered-opcode-sequence 3 1))" "(ns 'org.tomhume.so.Opcodes)" "(use 'org.tomhume.so.Opcodes)" "(count (expanded-numbered-opcode-sequence 3 1))" "(Reflector/invokeStaticMethod \\"java.lang.Math\\" max (into-array '[1 2]))" "(into-array '[3 2])" "(int 2)" "(count (expanded-numbered-opcode-sequence 4 2))" "(opcodes \:ixor)" "(\:ixor opcodes)" "opcodes" "(use 'org.tomhume.so.Opcodes)" "(\:ixor opcodes)" "(\:operand-needs (\:ixor opcodes))" "(\:opstack-needs (\:ixor opcodes))" "(first [\:ixor])" "((first [\:ixor]) opcodes)" "(\:opstack-needs ((first [\:ixor]) opcodes))" "(< (\:opstack-needs ((first [\:ixor]) opcodes)) 0)" "(if (< (\:opstack-needs ((first [\:ixor]) opcodes)) 0) false)" "(if (< (\:opstack-needs ((first [\:ixor]) opcodes)) 0) false true)" "(\= 0 (\:opstack-effect (\:ixor opcodes)))" "(+ 0 (\:opstack-effect (\:ixor opcodes)))" "(uses-operand-stack-ok? [\:ixor])" "(or (\= 1 1) (\= 1 0))" "(rest [\:ixor])" "(< (\:opstack-needs (\:ixor opcodes)) 0)" "(> (\:opstack-needs (\:ixor opcodes)) 0)" "(count (expanded-numbered-opcode-sequence 1 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 2 2))" "(count (expanded-numbered-opcode-sequence 2 3))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 3 2))" "(count (expanded-numbered-opcode-sequence 1 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 2 2))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 3 2))" "(count (expanded-numbered-opcode-sequence 1 1))" "(count (expanded-numbered-opcode-sequence 1 2))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 2 2))" "(count (expanded-numbered-opcode-sequence 3 1))" "(expanded-numbered-opcode-sequence 2 1)" "(use 'org.tomhume.so.Opcodes)" "(expanded-numbered-opcode-sequence 2 1)" "(use 'org.tomhume.so.Opcodes)" "1" "(def a {})" "(0 a)" "(get a 0)" "(put a 0 1)" "(assoc a 0 1)" "a" "(get (assoc a 0 1) 0)" "(\= \:load_0 \:iload_0)" "(\= \:iload_0 \:iload_0)" "(count (expanded-numbered-opcode-sequence 3 1))" "(assoc {} nil)" "(assoc {} nil nil)" "(count (\:args (\:ixor opcodes)))" "(count (\:args (\:istore opcodes)))" "(nthrest 1 '[1 2 3 4])" "(nthrest '[1 2 3 4] 1)" "(nthrest (+ 1 (count (\:args (\:istore opcodes)))) '[1 2 3 4] head)" "(nthrest (+ 1 (count (\:args (\:istore opcodes)))) '[1 2 3 4])" "(class opcodes)" "(+ 1 (count (\:args (\:istore opcodes))))" "(update-varmap '[\:iload_0])" "(assoc {} (update-varmap '[\:iload_0]))" "(partial assoc {} (update-varmap '[\:iload_0]))" "((partial assoc) {} (update-varmap '[\:iload_0]))" "((partial assoc {}) (update-varmap '[\:iload_0]))" "(partial assoc {})" "(let [map (update-varmap '[\:iload_0])]\\n  (assoc {} (nth map 0) (nth map 1)))" "(get '{0 \:write} 0)" "(update-varmap '[\:iload 12])" "(update-varmap '[\:iload_3])" "(update-varmap '[\:iload 12])" "(\= '(12 \:write) (update-varmap '[\:iload 12]))" "(update-varmap '[\:ixor])" "(update-varmap '[\:iload 12])" "(assoc {} (update-varmap '[\:iload 12]))" "(partial (assoc {}) (update-varmap '[\:iload 12]))" "((partial assoc) {} (update-varmap '[\:iload 12]))" "(update-varmap '[\:iload 12])" "(assoc {} (nth (update-varmap '[\:iload 12]) 1) (nth (update-varmap '[\:iload 12]) 2))" "(assoc {} (nth (update-varmap '[\:iload 12]) 0) (nth (update-varmap '[\:iload 12]) 1))" "(update-varmap '[\:iload 0])" "(update-varmap '[\:istore_0])" "(uses-vars-ok? [\:istore_0 \:iload 0 \:istore_0])" "(doc next)" "(nth '[1 2 3] 2)" "(uses-vars-ok? [\:istore_0 \:iload 0 \:istore_0])" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 4 1))" "(time \\n  (doall\\n        (superoptimise 2 class-name method-name method-signature eq-tests-filter)))" "(use 'org.tomhume.so.IdentitySO)" "(apply concat\\n       (pmap \#(%) (partition-all 10 (range 0 1000))))" "(apply concat (pmap \#(identity %) (partition-all 10 (range 0 1000))))" "(into {} (map \#(identity %) (range 0 2)))" "(into [] (map \#(identity %) (range 0 2)))" "(into {} (map \#((identity %) \:write) (range 0 2)))" "(into {} (map \#([(identity %) \:write]) (range 0 2)))" "(into {} (map \#(assoc {} (identity %) \:write)) (range 0 2))" "(into {} (map \#(assoc {} (identity %) \:write) (range 0 2)))" "(into {} (map \#(assoc {} (identity %) \:write) (range 0 nil)))" "(> 0 nil)" "(range 0 1)" "num-args" "method-signature" "1" "(count (expanded-numbered-opcode-sequence 1 1))" "(use 'org.tomhume.so.Main)" "(count (expanded-numbered-opcode-sequence 1 1))" "(use 'org.tomhume.so.Opcodes)" "(count (expanded-numbered-opcode-sequence 1 1))" "(time (doall (expanded-numbered-opcode-sequence 1 1)))" "(time (doall (expanded-numbered-opcode-sequence 2 1)))" "(time (doall (count (expanded-numbered-opcode-sequence 2 1))))" "(time  (count (expanded-numbered-opcode-sequence 2 1)))" "(time  (count (expanded-numbered-opcode-sequence 3 1)))" "(time  (count (expanded-numbered-opcode-sequence 4 1)))" "1" "(def cl (get-class (\:iload 0 \:bipush 2 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(use 'org.tomhume.so.Bytecode)" "(def cl (get-class (\:iload 0 \:bipush 2 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(def cl (get-class '(\:iload 0 \:bipush 2 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(invoke-method cl \\"signum\\" 1)" "(invoke-method cl \\"signum\\" 123123123)" "(invoke-method cl \\"signum\\" 0)" "(invoke-method cl \\"signum\\" 75084750234750983750982347)" "(invoke-method cl \\"signum\\" -1)" "(invoke-method cl \\"signum\\" Integer/MAXINT)" "(invoke-method cl \\"signum\\" Integer/MAXVALUE)" "(invoke-method cl \\"signum\\" Integer/MAX_VALUE)" "(invoke-method cl \\"signum\\" Integer/MIN_VALUE)" "(invoke-method cl \\"signum\\" -9283798274)" "(invoke-method cl \\"signum\\" -999)" "(invoke-method cl \\"signum\\" -10234)" "(def cl (get-class '(\:iload 0 \:bipush 254 \:irem \:return) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(def cl (get-class '(\:iload 0 \:bipush 254 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(invoke-method cl \\"signum\\" -10234)" "(invoke-method cl \\"signum\\" -999)" "(def cl (get-class '(\:iload 0 \:iconst_2 \:item \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(def cl (get-class '(\:iload 0 \:iconst_2 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(invoke-method cl \\"signum\\" -999)" "(invoke-method cl \\"signum\\" -10123)" "(invoke-method cl \\"signum\\" Integer/MAX_VALUE)" "(invoke-method cl \\"signum\\" Integer/MIN_VALUE)" "(invoke-method cl \\"signum\\" -999999)" "(invoke-method cl \\"signum\\" (+ 1 Integer/MIN_VALUE))" "(invoke-method cl \\"signum\\" Integer/MIN_VALUE)" "(Integer/MIN_VALUE)" "(def i (new Integer))" "(def i (new Integer Integer/MIN_VALUE))" "(.signum i)" "(123 Integer/signum)" "(Integer/signum 123)" "(Integer/signum Integer/MIN_VALUE)" "(Integer/signum Integer/MAX_VALUE)" "(invoke-method cl \\"signum\\" (+ 1 Integer/MIN_VALUE))" "(invoke-method cl \\"signum\\" (+ 2 Integer/MIN_VALUE))" "(invoke-method cl \\"signum\\" (+ 3 Integer/MIN_VALUE))" "(invoke-method cl \\"signum\\" (+ 4 Integer/MIN_VALUE))" "(expanded-numbered-opcode-sequence 2 1)" "(use 'org.tomhume.so.Opcodes)" "(expanded-numbered-opcode-sequence 2 1)" "(map \#(assoc % \:class (get-class (\:code %)  \\"IdentityTest\\" \\"identity\\" \\"(I)I\\" ))\\n             (expanded-numbered-opcode-sequence 2 (num-method-args \\"(I)I\\")))" "(def cl (get-class '(\:iload_0 \:ireturn) \\"Identity\\" \\"identity\\" \\"(I)I\\"))" "cl" "(check-passes eq-tests-filter cl)" "eq-tests-filter" "(defn one-is-one? [i] (\= 1 (invoke-method i method-name 1)))\\n(defn zero-is-zero? [i] (\= 0 (invoke-method i method-name 0)))\\n(defn minus-one-is-minus-one? [i] (\= -1 (invoke-method i method-name -1)))\\n(defn minint-is-minint? [i] (\= Integer/MIN_VALUE (invoke-method i method-name Integer/MIN_VALUE)))\\n(defn maxint-is-maxint? [i] (\= Integer/MAX_VALUE (invoke-method i method-name Integer/MAX_VALUE)))\\n(defn one-is-not-zero? [i] (not (\= 1 (invoke-method i method-name 0))))\\n(defn one-is-not-minus-one? [i] (not (\= 1 (invoke-method i method-name -1))))\\n\\n(def eq-tests-filter (test-map [one-is-one? zero-is-zero? minus-one-is-minus-one? minint-is-minint? maxint-is-maxint? one-is-not-zero? one-is-not-minus-one?]))" "(def class-name \\"IdentityTest\\")\\n(def method-name \\"identity\\")\\n(def method-signature \\"(I)I\\")\\n\\n; set up a map of equivalence tests\\n\\n(defn one-is-one? [i] (\= 1 (invoke-method i method-name 1)))\\n(defn zero-is-zero? [i] (\= 0 (invoke-method i method-name 0)))\\n(defn minus-one-is-minus-one? [i] (\= -1 (invoke-method i method-name -1)))\\n(defn minint-is-minint? [i] (\= Integer/MIN_VALUE (invoke-method i method-name Integer/MIN_VALUE)))\\n(defn maxint-is-maxint? [i] (\= Integer/MAX_VALUE (invoke-method i method-name Integer/MAX_VALUE)))\\n(defn one-is-not-zero? [i] (not (\= 1 (invoke-method i method-name 0))))\\n(defn one-is-not-minus-one? [i] (not (\= 1 (invoke-method i method-name -1))))\\n\\n(def eq-tests-filter (test-map [one-is-one? zero-is-zero? minus-one-is-minus-one? minint-is-minint? maxint-is-maxint? one-is-not-zero? one-is-not-minus-one?]))" "eq-tests-filter" "(check-passes eq-tests-filter cl)" "(passes? eq-tests-filter cl)" "\u00AC(import 'java.lang.Runtime) \\n(.maxMemory (Runtime/getRuntime))" "(import 'java.lang.Runtime) \\n(.maxMemory (Runtime/getRuntime))" "(get-children '[])" "(repeat 3 (rand-opcode-sequence 2))" "(rand-opcode-sequence 2)" "(repeatedly 3 (rand-opcode-sequence 2))" "(repeatedly 3 (partial rand-opcode-sequence 2))" "(rand-opcode-sequence 2)" "(repeatedly 3 (partial rand-opcode-sequence 2))" "(reduce + (partial (count (get-children)) (repeatedly 3 (partial rand-opcode-sequence 2))))" "(reduce (partial (+ count(get-children))) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce (partial + count get-children)) (repeatedly 3 (partial rand-opcode-sequence 2))" "(reduce + '[1 2 3 4])" "(repeatedly 3 (partial rand-opcode-sequence 2))" "reduce count (repeatedly 3 (partial rand-opcode-sequence 2))" "(reduce count (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce identity (repeatedly 3 (partial rand-opcode-sequence 2)))" "(repeatedly 3 (partial rand-opcode-sequence 2))" "(reduce (+ count) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce (partial + count) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce (partial (+ (count))) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce \#(+ (count %)) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce \#(+ (count %1) %2) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce \#(+ (count %2) %1) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(map \#(count (get-children %)) ((repeatedly 3 (partial rand-opcode-sequence 2))))" "(map \#(get-children %) ((repeatedly 3 (partial rand-opcode-sequence 2))))" "(map \#(get-children %) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(map \#(count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce + (map \#(count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 2))))" "(prune-stats 1)" "(prune-stats)" "(prune-stats 1)" "(def xyz 1)" "(range 1 (inc xyz))" "(prune-stats 1)" "(prune-stats 2)" "(/ 99 3)" "(prune-stats 2)" "(count (keys opcodes))" "(count keys opcodes)" "(reduce * (prune-stats 2))" "(* 39 39)" "(reduce * (prune-stats 6))" "(reduce * (prune-stats 12))" "(reduce * (prune-stats 11))" "(reduce * (prune-stats 2))" "(rand-opcode-sequence 10)" "(prune-stats 2)" "(prune-stats 0)" "(prune-stats 1)" "(prune-stats 2)" "(prune-stats 3)" "(prune-stats 2)" "(rand-opcode-sequence 2)" "(rand-opcode-sequence 3)" "(filter is-valid? (get-children '[\:ixor]))" "(filter is-valid? (get-children '[]))" "(prune-stats 2)" "(rand-opcode-sequence 3)" "(prune-stats 2)" "(get-children (keys opcodes))" "(map get-children (keys opcodes))" "(keys opcodes)" "(map get-children (seq (keys opcodes)))" "(map \#(get-children [%]) (keys opcodes))" "(prune-stats 2)" "(prune-stats 6)" "(repeatedly 3 (partial rand-opcode-sequence 4))" "((map \#(count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 4))))" "(map \#(count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 4)))" "(map \#((do (println %) (count (get-children %))) (repeatedly 3 (partial rand-opcode-sequence 4))))" "(map \#(do (println %) (count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 4))))" "(map \#(do (println %) (count (get-children %))) (repeatedly 3 (partial rand-opcode-sequence 4)))" "(count (get-children '(\:iconst_3 \:iconst_3 \:iconst_3 \:iconst_5))\\n       )" "(prune-stats 10)" "(prune-stats 3)" "(uses-operand-stack-ok? '(\:i2b \:iconst_4 \:iinc \:iconst_2))" "(uses-operand-stack-ok? '(\:ireturn \:iconst_4 \:iinc \:iconst_2))" "(uses-operand-stack-ok? '(\:iconst_4 \:iconst_4 \:iinc \:iconst_2))" "(prune-stats 12)" "(get-children '())" "(get-children '(\:iinc))" "(conj '(\:ixor) \:iinc)" "(conj '[\:ixor] \:iinc)" "(get-children '[\:iinc])" "(prune-stats 12)" "(prune-stats 6)" "(reduce * (prune-stats 6))" "(reduce (repeat 5 39))" "(repeat 5 39)" "(reduce * (repeat 5 39))" "(reduce * (prune-stats 6))" "(prune-stats 6)" "(reduce * '(34.0 33.78 34.9 33.15 32.81))" "(int (reduce * '(34.0 33.78 34.9 33.15 32.81)))" "(reduce * (repeat 5 39))" "(prune-stats 6)" "(subset?)" "(prune-performance 1)" "(prune-performance 2)" "(/ 79 100)" "(reduce * (prunt-stats 2))" "(reduce * (prune-stats 2))" "(reduce * (repeat (dec 2) (count (keys opcodes))))" "(count (keys opcodes))" "(prune-performance 3)" "(/ 100 79)" "(prune-performance 2)" "(prune-performance 3)" "(prune-performance 4)" "(prune-performance 5)" "(prune-performance 6)" "(prune-stats 6)" "(reduce * '(33.141 33.4304 33.2245 33.3556 33.254))" "(int (reduce * '(33.141 33.4304 33.2245 33.3556 33.254)))" "(reduce * (repeat 5 47))" "(reduce * (repeat 5 39))" "(reduce * (repeat 4 47))" "(count (get-children '[]))" "(rand-opcode-sequence 1)" "(prune-stats 6)" "(prune-stats 0)" "(prune-stats 1)" "(prune-stats 2)" "(prune-stats 3)" "(repeatedly 2 (partial rand-opcode-sequence 1))" "(map \#(count (get-children %)) (repeatedly 2 (partial rand-opcode-sequence 1)))" "(get-children '[\:iconst_m1])" "(count (get-children '[\:iconst_m1]))" "(count (get-children '[\:pop]))" "(count (get-children '[]))" "(range 0 4)" "(rand-opcode-sequence 0)" "(count (get-children (rand-opcode-sequence 0)))" "(map \#(count (get-children %))\\n\\t                 (repeatedly num-tests (partial rand-opcode-sequence 0)))" "(map \#(count (get-children %))\\n\\t                 (repeatedly 50 (partial rand-opcode-sequence 0)))" "(reduce + '(10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10))" "(/ 500 50)" "(prune-stats 5)" "(prune-stats 12)" "(map \#(float (% / 39)) '(10.0 20.8072 28.3805 30.2772 32.0268 32.607 33.4567 33.847 34.292 34.571 34.7561 35.0472))" "(map \#(float (/ % 39)) '(10.0 20.8072 28.3805 30.2772 32.0268 32.607 33.4567 33.847 34.292 34.571 34.7561 35.0472))" "(reduce * '(10.0 20.8072 28.3805 30.2772))" "(reduce * '(10.0 20.8072 28.3805 30.2772 500))" "(int (reduce * '(10.0 20.8072 28.3805 30.2772 500)))" "(reduce * '(39 39 39 39))" "(/ 178792.5398261712 2313441)" "(prune-stats 3)" "(prune-performance 6)" "(prune-performance 1)" "(reduce * (prune-stats 1))" "(prune-performance 1)" "(prune-performance 6)" "(prune-performance 12)" "(prune-performance 9)" "(prune-performance 1)" "(prune-performance 2)" "(* 0.052935 (reduce * (repeat 6 39)))" "(int (* 0.052935 (reduce * (repeat 6 39))))" "(int (* (prune-performance 5) (reduce * (repeat 6 39))))" "(reduce * (repeat 6 39))" "(redundant-pairs)" "redundant-pairs" "(def redundant-pairs '(\\n                        [\:swap \:swap]       ; Two swaps leave things as they were\\n                        [\:pop \:pop]         ; Could be replaced by \:pop2\\n                        ))" "redundant-pairs" "(reduce \#(%1 %2) redundant-pairs)" "(reduce \#(%) redundant-pairs)" "(map % redundant-pairs)" "(map \#(%) redundant-pairs)" "(map \#(first %) redundant-pairs)" "(reduce \#(first %) redundant-pairs)" "(first '[1 2 3])" "(next '[1 2 3])" "(second '[1 2 3])" "(contains-no-redundant-pairs? '[\:ixor \:swap \:swap])" "(doc contains-no-redundant-pairs?)" "(contains-no-redundant-pairs? '[\:ixor \:swap \:swap])" "(use 'org.tomhume.so.Opcodes)" "(contains-no-redundant-pairs? '[\:ixor \:swap \:swap])" "(loop [current '[1 2 3]]\\n       (if empty? current) true (recur (rest current)))" "(rest '[1 2 3])" "(.indexOf '(1 2 3) 2)" "(.indexOf '(1 2 3) 3)" "(for [l '[1 2 3]] l)" "(loop [l '[1 2 3 4]]\\n  (recur (rest l)))" "1" "(loop [l '[1 2 3 4]]\\n  (if empty? l) true\\n  (recur (rest l)))" "(loop [l '[1 2 3 4]]\\n  (println l)\\n  (if empty? l) true\\n  (recur (rest l)))" "(loop [l '[1 2 3 4]]\\n  ((println l)\\n  (if empty? l) true\\n  (recur (rest l))))" "(loop [l '[1 2 3 4]]\\n  (println l)\\n  (if (empty? l) true\\n    (recur (rest l))))" "1" "2" "(loop [l '[1 2 3 4]]\\n     (println \\"Hahahah\\" l)\\n     (if (empty? l) true\\n       (recur (rest l))))" "(loop [l '(1 2 3 4)]\\n     (println \\"Hahahah\\" l)\\n     (if (empty? l) true\\n       (recur (rest l))))" "1" "(loop [l '(1 2 3 4)]\\n   (if (empty? l) true\\n     (do \\n       (println \\"Not empty yet\\")\\n       (recur (rest l)))))" "(contains-no-redundant-pairs? '[\:pop \:pop])" "(contains-no-redundant-pairs? '[\:swap \:swap])" "(contains-no-redundant-pairs? '[\:swap \:pop])" "(contains-no-redundant-pairs? '[\:swap \:pop \:pop])" "(prune-stats 6)" "(use 'org.tomhume.so.PruningTests)" "(prune-stats 6)" "(prune-stats 8)" "1" "(opcode-sequence 2)" "(count (opcode-sequence 2))" "(count (opcode-sequence 3))" "(count (opcode-sequence 4))" "(count (opcode-sequence 3))" "(count (opcode-sequence 4))" "(time (count (opcode-sequence 4)))" "(opcode-sequence 2)" "(opcode-sequence 3)" "(count (opcode-sequence 3))" "(count (keys opcodes))" "(* 40 40)" "(count (opcode-sequence 3))" "(opcode-sequence 3)" "(count (opcode-sequence 3))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 3 2))" "(count (opcode-sequence 4 1))" "(time (count (opcode-sequence 4 1)))" "(take 10 (opcode-sequence 4 1))" "(count (opcode-sequence 4 1))" "(take 10 (opcode-sequence 4 1))" "(take 1 (opcode-sequence 4 1))" "(count (opcode-sequence 4 1))" "(time (count (opcode-sequence 4 1)))" "\u03C0" "(time (count (opcode-sequence 4 1)))" "(time (count (opcode-sequence 5 1)))" "(time (count (opcode-sequence 4 1)))" "(count (keys opcodes))" "(^ 39 4)" "(get-instructions '(\:iload_0 \:ireturn))" "(use 'org.tomhume.so.Bytecode)" "(get-instructions '(\:iload_0 \:ireturn))" "(.get (get-instructions '(\:iload_0 \:ireturn)) 0)" "(.opcode (.get (get-instructions '(\:iload_0 \:ireturn)) 0))" "(.getOpcode (.get (get-instructions '(\:iload_0 \:ireturn)) 0))" "1" "(count (expanded-numbered-opcode-sequence 3 1))" "(time (count (expanded-numbered-opcode-sequence 3 1)))" "(prunt-stats 6)" "(prune-stats 6)" "(use 'org.tomhume.so.PruningTests)" "(prune-stats 6)" "(get-children 1 '[])" "(count (get-children 1 '[]))" "(prune-stats 1)" "(count (get-children 1 '[\:ireturn]))" "(count (get-children 1 '[\:ixor]))" "(count (get-children 1 '[\:iconst_1]))" "(prune-stats 6)" "(prune-stats 2)" "(count (opcode-sequence 2 1))" "(count (let [fertile-children (partial get-children 1)]\\n  (rest (tree-seq \#(< (count 2) max-depth) fertile-children '[]))))" "(count (let [fertile-children (partial get-children 1)]\\n  (rest (tree-seq \#(< (count %) 2) fertile-children '[]))))" "(count (let [fertile-children (partial get-children 1)]\\n  (rest (tree-seq \#(< (count %) 3) fertile-children '[]))))" "(count (let [fertile-children (partial get-children 1)]\\n  (rest (tree-seq \#(< (count %) 1) fertile-children '[]))))" "(count (let [fertile-children (partial get-children 1)]\\n  (rest (tree-seq \#(< (count %) 4) fertile-children '[]))))" "(count (let [fertile-children (partial get-children 1)]\\n  (rest (tree-seq \#(< (count %) 5) fertile-children '[]))))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (expanded-numbered-opcode-sequence 1 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 4 1))" "(take 100 (expanded-numbered-opcode-sequence 3 1))" "(take 200 (expanded-numbered-opcode-sequence 3 1))" "(take 400 (expanded-numbered-opcode-sequence 3 1))" "(take 1000 (expanded-numbered-opcode-sequence 3 1))" "(take 5000 (expanded-numbered-opcode-sequence 3 1))" "(take 1 (expanded-numbered-opcode-sequence 3 1))" "(take 5000 (expanded-numbered-opcode-sequence 3 1))" "(first (drop 2068 (expanded-numbered-opcode-sequence 3 1)))" "(first (drop 2068 (opcode-sequence 3 1)))" "(count (opcodode-sequence 3 1))" "(count (opcode-sequence 3 1))" "(opcode-sequence 3 1)" "(first (drop 30 (opcode-sequence 3 1)))" "(first (drop 2068 (opcode-sequence 3 1)))" "(first (drop 2068 (expanded-numbered-opcode-sequence 3 1)))" "(count (filter (partial is-valid? 1) (opcode-sequence 3 1)))" "(filter (partial is-valid? 1) (opcode-sequence 3 1))" "(count (opcode-sequence 3 1))" "(count (filter (partial is-valid? 1) (opcode-sequence 3 1)))" "(count (filter (partial uses-vars-ok? 1) (opcode-sequence 3 1)))" "(count (filter \#(uses-vars-ok? 1 %) (opcode-sequence 3 1)))" "(uses-vars-ok? 1 '[\:bipush \:iload_3 \:ireturn])" "(uses-vars-ok? 1 '(\:bipush \:iload_3 \:ireturn))" "(count (opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 3 1))" "(prune-stats 6)" "(count (keys opcodes))" "(prune-stats 8)" "(count (opcode-sequence 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (opcode-sequence 6 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (expanded-numbered-opcode-sequence 1 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 4 1))" "(count (expanded-numbered-opcode-sequence 5 1))" "\#{1 2 3}" "(conj \#{1 2 3} 4)" "(doc contains)" "(doc? contains)" "doc contains" "(doc)" "(doc contains?)" "(doc some)" "(conj '() 1)" "(def tm {\:vars \#{} \:stack '()})" "tm" "(assoc tm \:stack (conj (\:stack tm) 0))" "(retains-influence? 1 '[\:iload_0 \:bipsuh \:\:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:\:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:ireturn])" "(some nil 0)" "(some \#{} 0)" "(doc some)" "(some 0 {})" "(some 0 {1})" "(some 0 \#{1})" "(some \#{0} \#{1})" "(some \#{0} \#{0})" "(some \#{0 1 2} \#{0})" "(some \#{0 1 2} \#{0 1 2})" "(retains-influence? 1 '[\:iload_0 \:bipush \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:iload_1 \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:istore_0 \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:istore_0 \:istore_1 \:ireturn])" "(assoc {} fred 1 ginger 2)" "(assoc {} \:fred 1 \:ginger 2)" "(retains-influence? 1 '[\:iload_0 \:bipush \:istore_0 \:istore_1 \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:istore_0 \:ireturn])" "(retains-influence? 1 '[\:istore_0 \:ireturn])" "(retains-influence? 1 '[\:bipush \:istore_0 \:ireturn])" "(retains-influence? 1 '[\:iload_1 \:istore_0 \:ireturn])" "(retains-influence? 1 '[\:iload_2 \:istore_0 \:ireturn])" "(retains-influence? 1 '[\:iload_2 \:istore_0 \:bipush \:ireturn])" "(retains-influence? 1 '[\:iload_2 \:istore_0 \:iload_0 \:ireturn])" "(range 0 2)" "(map \#(identity identity) (range 0 2))" "(map \#({identity identity}) (range 0 2))" "(map \#({% %}) (range 0 2))" "(map \#('{% %}) (range 0 2))" "(map \#({(identity %) 1}) (range 0 2))" "(map (into {}) (range 0 2))" "(map \#(into {} %) (range 0 2))" "(map \#(into {} % %) (range 0 2))" "(map \#(assoc {} % %) (range 0 2))" "into {} (map \#(assoc {} % %) (range 0 2))" "(into {} (map \#(assoc {} % %) (range 0 2)))" "(0 (into {} (map \#(assoc {} % %) (range 0 2))))" "(get (into {} (map \#(assoc {} % %) (range 0 2))) 0)" "(get (into {} (map \#(assoc {} % %) (range 0 2))) 1)" "(into {} (map \#(assoc {} % %) (range 0 4)))" "(retains-influence? 1 '[\:iload_2 \:istore_0 \:ireturn])" "(take 2 '(1 2 3 4 5))" "(into \#{} (take 2 '(1 2 3 4 5)))" "(doc conj)" "(retains-influence? 1 '[\:iload_2 \:istore_0 \:ireturn])" "(retains-influence? 1 '[\:iload_2 \:istore_0 \:idiv \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:bipush \:idiv \:ireturn])" "(retains-influence? 1 '[\:bipush \:bipush \:idiv \:ireturn])" "(into \#{} (take 2 '(1 nil 3 4 5)))" "(into \#{} (filter (not nil?) (take 2 '(1 nil 3 4 5))))" "(into \#{} (filter (not(nil?)) (take 2 '(1 nil 3 4 5))))" "(into \#{} (filter (partial not(nil?)) (take 2 '(1 nil 3 4 5))))" "(into \#{} \#(partial (not (nil))) (take 2 '(1 nil 3 4 5)))" "(into \#{} \#(partial (not (nil?))) (take 2 '(1 nil 3 4 5)))" "(into \#{} \#(partial (not (nil? %))) (take 2 '(1 nil 3 4 5)))" "(into \#{} (filter \#(partial (not (nil? %))) (take 2 '(1 nil 3 4 5))))" "(into \#{} (filter \#(partial not nil? %) (take 2 '(1 nil 3 4 5))))" "(into \#{} (filter \#(partial (not (nil? %))) (take 2 '(1 nil 3 4 5))))" "(filter (not nil?) '(1 2 3 4 5))" "(filter (not(nil?)) '(1 2 3 4 5))" "(filter \#(not(nil? %)) '(1 2 3 4 5))" "(filter \#(not(nil? %)) '(1 nil 3 4 5))" "(retains-influence? 1 '[\:bipush \:bipush \:idiv \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:iload_1 \:idiv \:ireturn])" "(concat (take 2 (\#{1} \#{0})))" "(take 2 (\#{1} \#{0}))" "(take 2 '(\#{1} \#{0}))" "(take 2 (\#{1} \#{0}))" "(doc union)" "(doc combine)" "(doc set)" "(retains-influence? 1 '[\:iload_0 \:iload_1 \:idiv \:ireturn])" "(retains-influence? 1 '[\:iload_0 \:iload_1 \:iload_2 \:idiv \:ireturn])" "(conj \#{2} \#{1})" "(doc union)" "(use 'clojure.set)" "(doc union)" "(union \#{2} \#{1})" "(retains-influence? 1 '[\:iload_0 \:iload_1 \:iload_2 \:idiv \:ireturn])" "(take 2 '(\#{1} \#{0}))" "(union (take 2 '(\#{1} \#{0})))" "(union (take 2 (\#{1} \#{0})))" "(take 2 (\#{1} \#{0}))" "(take 2 (seq (\#{1} \#{0})))" "(take 2 (seq \#{1} \#{0}))" "(seq (\#{0} \#{1}))" "[\#{0} \#{1}]" "[\#{0} \#{1} \#{2}]" "(take 2 [\#{0} \#{1} \#{2}])" "(apply union (take 2 [\#{0} \#{1} \#{2}]))" "(retains-influence? 1 '[\:iload_0 \:iload_1 \:iload_2 \:idiv \:ireturn])" "(retains-influence? 1\\n                    '[\:iload_1 \:iload_2 \:idiv \:istore_0 \:ireturn])" "(retains-influence? 1\\n                    '[\:iload_1 \:iload_2 \:idiv \:istore_0 \:iload_0 \:ireturn])" "(or nil 1)" "(or 1 nil)" "(retains-influence? 1\\n                    '[\:iload_1 \:iload_2 \:idiv \:istore_0 \:iload_0 \:ireturn])" "(get {0 \#{1 2}} 0)" "(or (get {0 \#{1 2}} 0) 0)" "(retains-influence? 1\\n                    '[\:iload_1 \:iload_2 \:idiv \:istore_0 \:iload_0 \:ireturn])" "(retains-influence? 1\\n                    '[\:iload_1 \:iload_2 \:idiv \:istore_0 \:iload_0 \:iload_0 \:ireturn])" "(set '(1 2))" "(set (range 0 2))" "(subset? (range 0 2) \#{0 1 2 3 4})" "(has-influence? 1 \#{0 2})" "(retains-influence? 1\\n                    '[\:iload_1 \:iload_2 \:idiv \:istore_0 \:iload_0 \:iload_0 \:ireturn])" "{\:vars {} \:stack (\#{1} \#{1} \#{2})}" "{\:vars {} \:stack (seq (\#{1} \#{1} \#{2}))}" "\#{1}" "(seq (\#{1} \#{1} \#{2}))" "[\#{1} \#{1}]" "(seq \#{1} \#{2})" "(seq (\#{1} \#{2}))" "(seq (\#{1} \#{2} \#{3}))" "(list (\#{1} \#{2} \#{3}))" "'(\#{1} \#{2} \#{3})" "(first '(\#{1} \#{2} \#{3}))" "(subset (first '(\#{1} \#{2} \#{3})) \#{1 2 3})" "(subset? (first '(\#{1} \#{2} \#{3})) \#{1 2 3})" "(iterate 2 pop '(1 2 3 4))" "(take 2 (iterate pop '(1 2 3 4)))" "(nthrest '(1 2 3 4) 2)" "(first '(\#{1} \#{2}))" "(second '(\#{1} \#{2}))" "(nthrest '(\#{1} \#{2}) 2)" "(concat (first '(\#{1} \#{2})) (second '(\#{1} \#{2})))" "(conj (first '(\#{1} \#{2})) (second '(\#{1} \#{2})))" "(cons (first '(\#{1} \#{2})) (second '(\#{1} \#{2})))" "(first '(\#{1} \#{2}))" "(second '(\#{1} \#{2}))" "(conj (first '(\#{1} \#{2})) (first '(\#{1} \#{2})))" "(cons (first '(\#{1} \#{2})) (first '(\#{1} \#{2})))" "(conj (seq((first '(\#{1} \#{2})))))" "(conj (seq((first '(\#{1} \#{2})))) (seq((first '(\#{1} \#{2})))))" "(conj (seq(first '(\#{1} \#{2}))) (seq(first '(\#{1} \#{2}))))" "(concat (seq(first '(\#{1} \#{2}))) (seq(first '(\#{1} \#{2}))))" "(conj (first '(\#{1} \#{2})) (seq(first '(\#{1} \#{2}))))" "(reverse (take 2 '(\#{1} \#{2})))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 4 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 4 1))" "(count (expanded-numbered-opcode-sequence 5 1))" "(count (opcode-sequence 5 1))" "(count (opcode-sequence 6 1))" "(count (opcode-sequence 7 1))" "(time (doall (superoptimise-pmap 4 class-name method-name method-signature eq-tests-filter)))" "(count (expanded-numbered-opcode-sequence 4 1))" "(use 'org.tomhume.so.Opcodes)" "(count (expanded-numbered-opcode-sequence 4 1))" "(time (count (expanded-numbered-opcode-sequence 4 1)))" "1" "(+ 1 1)" "1" "(float 353383/3518743761)" "1" "(time (count (expanded-numbered-opcode-sequence 4 1)))" "(use 'org.tomhume.so.Opcodes)" "(time (count (expanded-numbered-opcode-sequence 4 1)))" "1" "(time (count (opcode-sequence 4 1)))" "(time (count (expanded-numbered-opcode-sequence 4 1)))" "(mod 1000 10)" "(mod 6 3)" "(mod 6 4)" "(test-recreate-cl-every 1 1)" "1" "(test-recreate-cl-every 1 1)" "(test-recreate-cl-every 1000 1)" "(test-recreate-cl-every 50000 1)" "(time (test-recreate-cl-every 100000 1))" "(time (test-recreate-cl-every 100000 100000))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'org.tomhume.so.ClassLoaderSpeed)))" "(time (test-recreate-cl-every 100000 100000))" "(time (test-recreate-cl-every 100000 1))" "(time (test-recreate-cl-every 100000 50000))" "(time (test-recreate-cl-every 200000 50000))" "(time (test-recreate-cl-every 200000 1))" "(time (test-recreate-cl-every-hold-asm-refs 100000 50000))" "(time (test-recreate-cl-every-hold-asm-refs 100000 1))" "(time (test-recreate-cl-every-hold-asm-refs 10 1))" "(time\\n  (test-recreate-cl-every-hold-asm-refs 100000 50000))" "(time\\n  (test-recreate-cl-every 100000 50000))" "(time\\n  (test-recreate-cl-every-hold-asm-refs 100000 50000))" "(init-state 1)" "(into {} (map \#(% 0) (range 0 2)))" "(into {} (map \#([% 0]) (range 0 2)))" "(map \#([% 0]) (range 0 2))" "(map \#(vec(% 0)) (range 0 2))" "(map \#('(% 0)) (range 0 2))" "(map \#('[% 0]) (range 0 2))" "(range 0 2)" "(map \#(identity %) (range 0 2))" "(map \#([(identity %) 0]) (range 0 2))" "[1 1]" "[(identity 1) 1]" "(map \#('[(identity %) 0]) (range 0 2))" "(apply assoc {} (interleave (range 0 2) 0))" "(apply assoc {} (interleave (range 0 2) (range 0 2)))" "(apply assoc {} (interleave (range 0 2) (range 0 0)))" "(apply assoc {} (interleave (range 0 2) (repeat 0))\\n       )" "(apply assoc {} (interleave (range 0 2) (repeat 3)))" "(init-state 3)" "(\:vars (init-state 3))" "(2 (\:vars (init-state 3)))" "(get (\:vars (init-state 3)) 2)" "(let [sm (init-state 3)]\\n  (assoc sm \:max-var (inc (\:max-var sm)))\\n  )" "(let [sm (init-state 3)]\\n  (assoc sm \:max-var (inc (\:max-var sm))))" "(let [sm (init-state 3)]\\n  (assoc sm \:max-var 1))" "(let [sm (init-state 3)]\\n  (assoc sm \:max-var (inc (\:max-var sm))))" "(cons '() 1)" "(conj '() 1)" "(conj '(1 2 3) 1)" "(conj '(1 2 3) 1 2)" "(add-state (init-state 1) \:bipush)" "(cons \:a \:b)" "(seq \:a \:b)" "(seq (\:a \:b))" "(seq '(\:a \:b))" "(add-state (init-state 1) \:bipush)" "(seq [\:a \:b])" "(add-state (init-state 1) \:bipush)" "(add-state (add-state (init-state 1) \:bipush) \:bipush)" "(add-state (init-state 1) \:bipush)" "(add-state (add-state (init-state 1) \:bipush) \:bipush)" "(add-state (add-state (init-state 1) \:bipush) \:dup)" "(range 1)" "(add-state (add-state (init-state 1) \:bipush) \:dup)" "'(1 2 3)" "(def tl '(1 2 3 4 5))" "tl" "(concat (second tl) (first tl) (nthrest tl 2))" "(concat (second tl) (first tl) (nthrest 2 tl))" "(second tl)" "(first tl)" "(nthrest tl 3)" "(concat (seq ((second tl) (first tl))) (nthrest 2 tl))" "(concat (cons ((second tl) (first tl))) (nthrest 2 tl))" "(cons 1 2)" "(conj 1 2)" "(into '() 1 2)" "(into '() 1)" "(concat (list ((second tl) (first tl))) (nthrest 2 tl))" "(list 1 2)" "(concat (list (second tl) (first tl)) (nthrest 2 tl))" "(list (second tl) (first tl))" "(concat (list (second tl) (first tl)) '(1 2 3))" "(concat (list (second tl) (first tl)) (nthrest 2 tl))" "(concat (list (second tl) (first tl)) (nthrest tl 2))" "(add-state\\n        '{\:stack ([\:constant 1] [\:constant 2] [\:constant 3]), \:max-var 0, \:max-const 4, \:max-calc 0, \:vars {0 0}}\\n        \:iadd)" "(doc \:fred)" "(name \:fred)" "(keyword \\"fred\\")" "(map \#(keyword (str \\"arg-\\" %)) (range 0 3))" "(into {} (map \#(keyword (str \\"arg-\\" %)) (range 0 3)))" "(into {} (map \#([keyword (str \\"arg-\\" %) 0]) (range 0 3)))" "(into {} (map \#(list(keyword (str \\"arg-\\" %) 0)) (range 0 3)))" "(into {} (map \#(list((keyword (str \\"arg-\\" %)) 0)) (range 0 3)))" "(into {} (map \#((keyword (str \\"arg-\\" %)) 0)) (range 0 3))" "(into {}\\n      (map \#((keyword (str \\"arg-\\" %)) 0)\\n           (range 0 3)))" "(into {}\\n      (map \#([(keyword (str \\"arg-\\" %)) 0])\\n           (range 0 3)))" "(map \#(identity %) (range 3))" "(apply hash-map (map \#(identity %) (range 3)))" "(apply hash-map (map \#(list((identity %)(identity %)) (range 3))))" "(apply hash-map\\n       (map \#(list((identity %)(identity %))) (range 3)))" "(apply hash-map\\n       (map \#(list( (identity %) (identity %))) (range 3)))" "(def in '(0 1 2 3 4))" "(map \#(keyword(str \\"arg-\\" %)) in)" "(interleave \#(keyword(str \\"arg-\\" %)) in)" "(interleave (map \#(keyword(str \\"arg-\\" %)) in) in)" "(interleave (map \#(keyword(str \\"arg-\\" %)) in) (repeat 0))" "(interleave (map \#(keyword(str \\"arg-\\" %)) (range 3)) (repeat 0))" "(into {} (interleave (map \#(keyword(str \\"arg-\\" %)) (range 3)) (repeat 0)))" "(hash-map (interleave (map \#(keyword(str \\"arg-\\" %)) (range 3)) (repeat 0)))" "(into hash-map (interleave (map \#(keyword(str \\"arg-\\" %)) (range 3)) (repeat 0)))" "(into {} '(1 2 3 4))" "(into {} '[1 2 3 4])" "(hash-map '(1 2 3 4))" "(apply hash-map '(1 2 3 4))" "(init-state 4)" "(str \\"arg-1\\" 1)" "(init-state 4)" "(init-state 1)" "(def m {0 [\:arg-0] 1 nil 2 nil 3 nil})" "m" "(def c 12)" "(map \#(identity %) (keys m))" "(map \#(% m) (keys m))" "(map \#(get m %) (keys m))" "(let [i (atom 0)]\\n  (map \#([m (swap\! i inc)]) (keys m)))" "(let [i (atom 0)]\\n  (map \#([% (swap\! i inc)]) (keys m)))" "(let [i (atom 0)]\\n  (map \#([(identity %) (swap\! i inc)]) (keys m)))" "(let [i (atom 0)]\\n  (map \#([identity %]) (keys m)))" "(let [i (atom 0)]\\n  (map \#(list (identity %)) (keys m)))" "(let [i (atom 0)]\\n  (map \#(list (identity %) (swap\! i inc)) (keys m)))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (map \#(list (identity %) (swap\! i inc)) (keys m))))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (map \#([(identity %) (swap\! i inc)]) (keys m))))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (map \#(list (identity %) (swap\! i inc)) (keys m))))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (into {} (map \#(list (identity %) (swap\! i inc)) (keys m)))))" "(let [i (atom 0)]\\n            (into {} (map \#(list (identity %) (swap\! i inc)) (keys m))))" "(let [i (atom 0)]\\n           (map \#(list (identity %) (swap\! i inc)) (keys m)))" "(let [i (atom 0)]\\n           (map \#({(identity %) (swap\! i inc)}) (keys m)))" "(let [i (atom 0)]\\n           (map \#(into {} list ((identity %) (swap\! i inc))) (keys m)))" "(let [i (atom 0)]\\n           (apply hash-map (interleave (repeat (swap\! i inc)) (keys m))))" "(let [i (atom 0)]\\n           (apply hash-map (interleave (iterate (swap\! i inc)) (keys m))))" "(let [i (atom 0)]\\n           (apply hash-map (repeatedly (iterate (swap\! i inc)) (keys m))))" "(let [i (atom 0)]\\n           (apply hash-map (interleave (repeatedly (swap\! i inc)) (keys m))))" "(let [i (atom 0)](take 5 (repeatedly (swap\! i inc))))" "(let [i (atom 0)]\\n         (into {} (map \#(list (identity %) (swap\! i inc)) (keys m))))" "(let [i (atom 0)]\\n         (into {} (map \#(list ((identity %) (swap\! i inc))) (keys m))))" "(let [i (atom 0)]\\n        (map \#(list ((identity %) (swap\! i inc))) (keys m)))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (into {} (map \#(list (identity %) (swap\! i inc)) (keys m)))))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (map \#([(identity %) (swap\! i inc)]) (keys m))))" "(let [i (atom 0)]\\n  (map \#(list (identity %) (swap\! i inc)) (keys m)))" "(let [i (atom 0)]\\n  (interleave (repeatedly (swap\! i inc)) (keys m)))" "(let [i (atom 0)]\\n  (interleave (repeatedly (swap\! i inc))\\n              (keys m)))" "(let [i (atom 0)]\\n  (swap\! i inc))" "(let [i (atom 0)]\\n  (repeatedly (swap\! i inc)))" "(let [i (atom 0)]\\n  (repeatedly \#(swap\! i inc)))" "(let [i (atom 0)]\\n  (take 10 (repeatedly \#(swap\! i inc))))" "(let [i (atom 0)]\\n  (interleave (repeatedly \#(swap\! i inc))\\n              (keys m)))" "(apply hash-map\\n       (let [i (atom 0)]\\n         (interleave (repeatedly \#(swap\! i inc))\\n              (keys m))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (repeatedly \#(swap\! i inc))\\n              (keys m))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (keys m)\\n         (interleave (repeatedly \#(swap\! i inc)))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         \\n         (interleave (keys m) (repeatedly \#(swap\! i inc)))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(swap\! i inc)))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#([\:var (swap\! i inc)])))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#('[\:var (swap\! i inc)])))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(vec (\:var (swap\! i inc)))))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(vec ('\:var (swap\! i inc)))))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(\:var (swap\! i inc))))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#([\:var (swap\! i inc)])))))" "[\:var 1]" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#[\:var (swap\! i inc)]))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(vec {\:var (swap\! i inc)})))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(vec \:var (swap\! i inc))))))" "(vec \:var 1)" "(vec (\:var 1))" "(vec '(\:var 1))" "(vec '(\:var 1) '(\:var 2))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#([\:var (swap\! i inc)])))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(list \:var (swap\! i inc))))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(vec \:var (swap\! i inc))))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(list \:var (swap\! i inc))))))" "(apply hash-map\\n       (let [i (atom 21)]\\n         (interleave (keys m) (repeatedly \#(vector \:var (swap\! i inc))))))" "(prune-stats 6)" "(use 'org.tomhume.so.PruningTests)" "(prune-stats 6)" "(prune-stats 8)" "(count (expanded-numbered-opcode-sequences 2 1))" "(use 'org.tomhume.so.Opcodes)" "(count (expanded-numbered-opcode-sequences 2 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 5 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 1 1))" "(count (opcode-sequence 2 1))" "(count (opcode-sequence 3 1))" "(count (opcode-sequence 4 1))" "(count\\n  (expanded-numbered opcode-sequence 2 1))" "(count\\n  (expanded-numbered-opcode-sequence 2 1))" "(count\\n  (expanded-numbered-opcode-sequence 3 1))" "(count\\n  (expanded-numbered-opcode-sequence 4 1))" "(doc swap\!)" "1" "(mod 5000 1000)" "(doc do)" "1" "2" "3" "1" "classloader" "(use 'Main.Bytecode)" "classloader" "@classloader" "instantiate-classloader" "(instantiate-classloader)" "(instantiate-classloader 1)" "1" "(doc swap\!)" "(doc set\!)" "(doc swap\!)" "(init-classloader)" "(instantiate-classloader)" "(instantiate-classloader 1)" "(init-classloader)" "classloader" "@classloader" ".defineClass" "(is (\= true (no-redundancy? 1 '[\:iload_0 \:ireturn])))" "(use 'clojure.test)" "(is (\= true (no-redundancy? 1 '[\:iload_0 \:ireturn])))" "(use '[Filters.RedundancyFilter])" "(is (\= true (no-redundancy? 1 '[\:iload_0 \:ireturn])))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'Main.Bytecode)))" "(def classloader (atom (new clojure.lang.DynamicClassLoader)))" "(swap\! classloader instantiate-classloader)" "(use 'Main.Bytecode)" "(swap\! classloader instantiate-classloader)" "classloader" "1" "(time (count (expanded-numbered-opcode-sequence 5 1)))" "(use 'Main.Opcodes)" "(time (count (expanded-numbered-opcode-sequence 5 1)))" "(time-limited 1000 (sleep 100000))" "(use 'Util.TestMap)" "(time-limited 1000 (sleep 100000))" "(time-limited 1000 (Thread/sleep 100000))" "(time-limited 1000 (Thread/sleep 100))" "(time-limited 1000 (Thread/sleep 1001))" "(time-limited 1000 true)" "1"]
eclipse.preferences.version=1
