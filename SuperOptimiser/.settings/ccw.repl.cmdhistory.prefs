cmdhistory=["(use 'Opcodes)" "(opcode-sequence 2)" "1" "2" "(opcode-sequence 4)" "(mapcat identity (((\:istore 0 \:istore 0) (\:istore 0 \:istore 1) (\:istore 1 \:istore 0) (\:istore 1 \:istore 1)) ((\:ixor \:ireturn))))" "(mapcat identity '(((\:istore 0 \:istore 0) (\:istore 0 \:istore 1) (\:istore 1 \:istore 0) (\:istore 1 \:istore 1)) ((\:ixor \:ireturn))))" "(mapcat identity '((\:istore 0 \:istore 0) (\:istore 0 \:istore 1) (\:istore 1 \:istore 0) (\:istore 1 \:istore 1)) ((\:ixor \:ireturn)))" "(mapcat identity '(((a b) (c d))((e f))))" "(mapcat identity '((a b) (c d))((e f)))" "1" "(nthrest '(\:a \:b \:c \:d \:e) 2)" "(nthrest 2 '(\:istore \:arg \:ireturn))" "(use org.tomhume.so.Opcodes)" "(use 'org.tomhume.so.Opcodes)" "(opcodes \:pop)" "((opcodes \:pop) \:opcode)" "(new InsnNode 87)" "(new InsnNode ((opcodes \:pop) \:opcode))" "(. (new InsnList) add (new InsnNode ((opcodes \:pop) \:opcode)))" "(next '(1 2 3))" "\:arg" "(\:arg)" "(first '[ 1 2 3])" "(second '[ 1 2 3])" "(nthrest '(1 2 3 4) 0)" "(opcodes \:pop)" "(((opcodes \:istore) \:args) count)" "(opcodes \:istore)" "((opcodes \:istore) \:args)" "(count ((opcodes \:istore) \:args))" "(ns some.Example\\n  (\:gen-class))\\n\\n(defn -toString\\n  [this]\\n  \\"Hello, World\!\\")" "(some.Example.)" "(-toString (some.Example.))" "(use 'some.Example)" "('some.Example/-toString)" "(-toString (some.Example.))" "(gen-and-load-class 'foo.MyClass\\n   \:methods [['mymethod [String] String]\\n             ['finalize [] Void/TYPE]])" "(ns test.test\\n    (\:gen-class))\\n\\n(defn -main\\n    [gre]\\n    (println (str \\"Hello \\" gre)))" "(test.test)" "(compile 'test.test)" "(test.test.)" "(ns some.Example\\n  (\:gen-class))\\n\\n(defn -toString\\n  [this]\\n  \\"Hello, World\!\\")" "(-toString (some.Example.))" "(ns org.tomhume.so.Bytecode)" "(reflect ClassLoader)" "(use 'clojure.reflect)" "(reflect ClassLoader)" "(reflect ClassLoader \:members)" "(def test-proxy (proxy [Object] [] (test-method [] (println \\"a\\"))))" "text-proxy" "test-proxy" "(test-method test-proxy)" "(test-proxy test-method)" "(.test-method test-proxy)" "(def test-proxy (proxy [Object] [] (testMethod [] (println \\"a\\"))))" "(.testMethod test-proxy)" "(type test-proxy)" "(do-reflect test-proxy)" "(reflect test-proxy)" "(class test-proxy)" "(def test-proxy (proxy [Object] [] (toString [] (println \\"a\\"))))" "(.toString test-proxy)" "(def test-proxy (proxy [ClassLoader] [] (defineClass [name bytes offset len] (proxy-super name bytes offset len))))" "(.defineClass test-proxy \\"a\\" \\"b\\" 0 1)" "(def test-proxy (proxy [ClassLoader] [] (defineClass [name bytes offset len] (proxy-super defineClass name bytes offset len))))" "(.defineClass test-proxy \\"a\\" \\"b\\" 0 1)" "(reflect test-proxy)" "(use 'clojure.reflect)" "(reflect cg)" "(.dummy cg)" "(-dummy cg)" "(.dummy cg)" "(class cg)" "(.dummy cg)" "(-dummy cg)" "(.dummy cg a)" "(.dummy cg 'a)" "(.dummy cg)" "(-dummy cg)" "cg" "(class cg)" "(use 'clojure.reflect)" "(reflect cg)" "(.dummy cg)" "(-dummy cg)" "(reload-class 'a l)" "(reload-class 'a 'l)" "(use 'clojure.reflect)" "(reflect f)" "(reflect f1)" "(reflect f2)" "(reflect f1)" "(reflect f2)" "(.identity f1 1)" "f1" "(class f1)" "(def method (.getDeclaredMethod f1 \\"identity\\" Integer/TYPE))" "(.getDeclaredMethod f1 \\"identity\\" 1)" "(reflect f1)" "(type f1)" "(.identity f1)" "(.identity f1 1)" "(f1/identity 1)" "(IdentityTest1/identity 1)" "(IdentityTest1/identity)" "(type f1)" "(import IdentityTest1)" "(class f1)" "(reflect f1)" "(identity f1)" "(id f1)" "(f1 id)" "(reflect f1)" "(reflect f2)" "(id_two f2)" "(.id_two f2)" "(.idTwo IdentityTwo 1)" "(.idTwo IdentityTest-2 1)" "(IdentityTestTwo/idTwo 1)" "(IdentityTest-2)" "(IdentityTest-2/idTwo 2)" "(IdentityTest-2/id_two 2)" "(IdentityTest-1/id_two 2)" "(IdentityTest-1/identity 2)" "(f1/identity 2)" "(type f1)" "(. ~f1)" "(. ~f1 identity 1)" "(import 'clojure.lang.Reflector)" "(import clojure.lang.Reflector)" "(import 'clojure.lang.Reflector)" "(Reflector/invokeStaticMethod Integer \\"parseInt\\" (into-array [\\"1\\"]))" "(defmacro static-call [var method & args]\\n  `(-> (.getName ~var)\\n       (symbol ~(str method))\\n       (list ~@args)\\n       eval))" "(static-call \\"IdentityTest-2\\" \\"identity\\" 1)" "(static-call f1 'identity 1)" "(static-call f1 \\n             \\"identity\\" 1)" "opcodes" "1" "(def f1 (get-class '(\:iload 0 \:ireturn) \\"IdentityTest-1\\" \\"identity\\" \\"(I)I\\"))" "type f1" "(type f1)" "(def f1 (get-class '(\:iload 0 \:ireturn) \\"IdentityTest-1\\" \\"identity\\" \\"(I)I\\"))" "(mapcat identity (map expand-opcodes (opcode-sequence 2)))" "(map \#(println (\:code %))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2))))" "(map \#(println (% \:code))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2))))" "(map \#(println %)\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2))))" "(count (map \#(println %)\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(count (map \#(println (first %))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(count (map \#(println (\:code %))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(count (map \#(println (\:code %))\\n     (first (mapcat identity (map expand-opcodes (opcode-sequence 2))))))" "(count (map \#(println %)\\n     (first (mapcat identity (map expand-opcodes (opcode-sequence 2))))))" "(first (map \#(println %)\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(first (map expand-opcodes (opcode-sequence 2)))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'org.tomhume.so.Opcodes)))" "(first (map \#(println %)\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(first (map \#(println (\:code %))\\n     (mapcat identity (map expand-opcodes (opcode-sequence 2)))))" "(let [seqnum 0]\\n  (4 seqnum))" "(System/gc)" "\\n(defn a \\"\\" [] (try (do (1/0) true) (catch Exception e false)))" "(defn a \\"\\" [b] (try (do (1/b) true) (catch Exception e false)))" "(defn a \\"\\" [b] (try (1/b) (catch Exception e 999))\\n  )" "(defn a \\"\\" [b] (try (/ 1 b) (catch Exception e 999)))" "(a 1)" "(a 0)" "(defn a \\"\\" [b] (try (> 0 (/ 1 b)) (catch Exception e 999)))" "(a 1)" "(a 0.1)" "(defn a \\"\\" [b] (try (> (/ 1 b) 0) (catch Exception e 999)))" "(a 1)" "(a 0.1)" "(a 0)" "(defn a \\"\\" [b] (try (> (/ 1 b) 0) (catch Exception e false)))" "(a 0)" "(def newInt (new Integer))" "(def newInt (new Integer 3))" "newInt" "(static-call newInt \\"parseInt\\" \\"1\\")" "(static-call (class newInt) \\"parseInt\\" \\"1\\")" "(static-call (class newInt) \\"parseInt\\" \\"123\\")" "(class meth-name)" "(def meth-name \\"parseInt\\")" "(static-call (class newInt meth-name \\"123\\"))" "(static-call (class newInt) meth-name \\"123\\")" "(symbol meth-name)" "(defmacro static-call [var method & args]\\n     `(-> (.getName ~var)\\n          (symbol ~method)\\n          (list ~@args)\\n          eval))" "(ns-unmap 'org.tomhume.so.Bytecode static-call)" "(ns-unmap 'org.tomhume.so.Bytecode 'static-call)" "(defmacro static-call [var method & args]\\n        `(-> (.getName ~var)\\n             (symbol ~method)\\n             (list ~@args)\\n             eval))" "(static-call (class newInt) meth-name \\"123\\")" "(import 'clojure.lang.Reflector)" "(Reflector/invokeStaticMethod Integer meth-name (into-array [\\"1\\"]))" "(map expand-opcodes (opcode-sequence 2))" "(map-indexed expand-opcodes (opcode-sequence 2))" "(expanded-numbered-opcode-sequence 2)" "(range 0 0)" "1" "(expanded-numbered-opcode-sequence 3 1)" "1" "(count (expanded-numbered-opcode-sequence 3 1))" "(mod 2 3)" "(mod 100 10)" "(mod 101 10)" "(let [num 1001] (doall (if (\= (0 (mod num 1000))) (println num))))" "(let [num 1001] (if (\= (0 (mod num 1000))) (println num)))" "(if (\= 0 (mod num 1000)) (println \\"hello\\"))" "(if (\= 0 (mod 1001 1000)) (println \\"hello\\"))" "(if (\= 0 (mod 2000 1000)) (println \\"hello\\"))" "(ns-publics 'org.tomhume.so.Main)" "(ns-publics 'org.tomhume.so.IdentitySO)" "(ns-publics 'org.tomhume.so.LoadManyClasses)" "1" "(count (expanded-numbered-opcode-sequence 3 1))" "(ns 'org.tomhume.so.Opcodes)" "(use 'org.tomhume.so.Opcodes)" "(count (expanded-numbered-opcode-sequence 3 1))" "(Reflector/invokeStaticMethod \\"java.lang.Math\\" max (into-array '[1 2]))" "(into-array '[3 2])" "(int 2)" "(count (expanded-numbered-opcode-sequence 4 2))" "(opcodes \:ixor)" "(\:ixor opcodes)" "opcodes" "(use 'org.tomhume.so.Opcodes)" "(\:ixor opcodes)" "(\:operand-needs (\:ixor opcodes))" "(\:opstack-needs (\:ixor opcodes))" "(first [\:ixor])" "((first [\:ixor]) opcodes)" "(\:opstack-needs ((first [\:ixor]) opcodes))" "(< (\:opstack-needs ((first [\:ixor]) opcodes)) 0)" "(if (< (\:opstack-needs ((first [\:ixor]) opcodes)) 0) false)" "(if (< (\:opstack-needs ((first [\:ixor]) opcodes)) 0) false true)" "(\= 0 (\:opstack-effect (\:ixor opcodes)))" "(+ 0 (\:opstack-effect (\:ixor opcodes)))" "(uses-operand-stack-ok? [\:ixor])" "(or (\= 1 1) (\= 1 0))" "(rest [\:ixor])" "(< (\:opstack-needs (\:ixor opcodes)) 0)" "(> (\:opstack-needs (\:ixor opcodes)) 0)" "(count (expanded-numbered-opcode-sequence 1 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 2 2))" "(count (expanded-numbered-opcode-sequence 2 3))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 3 2))" "(count (expanded-numbered-opcode-sequence 1 1))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 2 2))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 3 2))" "(count (expanded-numbered-opcode-sequence 1 1))" "(count (expanded-numbered-opcode-sequence 1 2))" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 2 2))" "(count (expanded-numbered-opcode-sequence 3 1))" "(expanded-numbered-opcode-sequence 2 1)" "(use 'org.tomhume.so.Opcodes)" "(expanded-numbered-opcode-sequence 2 1)" "(use 'org.tomhume.so.Opcodes)" "1" "(def a {})" "(0 a)" "(get a 0)" "(put a 0 1)" "(assoc a 0 1)" "a" "(get (assoc a 0 1) 0)" "(\= \:load_0 \:iload_0)" "(\= \:iload_0 \:iload_0)" "(count (expanded-numbered-opcode-sequence 3 1))" "(assoc {} nil)" "(assoc {} nil nil)" "(count (\:args (\:ixor opcodes)))" "(count (\:args (\:istore opcodes)))" "(nthrest 1 '[1 2 3 4])" "(nthrest '[1 2 3 4] 1)" "(nthrest (+ 1 (count (\:args (\:istore opcodes)))) '[1 2 3 4] head)" "(nthrest (+ 1 (count (\:args (\:istore opcodes)))) '[1 2 3 4])" "(class opcodes)" "(+ 1 (count (\:args (\:istore opcodes))))" "(update-varmap '[\:iload_0])" "(assoc {} (update-varmap '[\:iload_0]))" "(partial assoc {} (update-varmap '[\:iload_0]))" "((partial assoc) {} (update-varmap '[\:iload_0]))" "((partial assoc {}) (update-varmap '[\:iload_0]))" "(partial assoc {})" "(let [map (update-varmap '[\:iload_0])]\\n  (assoc {} (nth map 0) (nth map 1)))" "(get '{0 \:write} 0)" "(update-varmap '[\:iload 12])" "(update-varmap '[\:iload_3])" "(update-varmap '[\:iload 12])" "(\= '(12 \:write) (update-varmap '[\:iload 12]))" "(update-varmap '[\:ixor])" "(update-varmap '[\:iload 12])" "(assoc {} (update-varmap '[\:iload 12]))" "(partial (assoc {}) (update-varmap '[\:iload 12]))" "((partial assoc) {} (update-varmap '[\:iload 12]))" "(update-varmap '[\:iload 12])" "(assoc {} (nth (update-varmap '[\:iload 12]) 1) (nth (update-varmap '[\:iload 12]) 2))" "(assoc {} (nth (update-varmap '[\:iload 12]) 0) (nth (update-varmap '[\:iload 12]) 1))" "(update-varmap '[\:iload 0])" "(update-varmap '[\:istore_0])" "(uses-vars-ok? [\:istore_0 \:iload 0 \:istore_0])" "(doc next)" "(nth '[1 2 3] 2)" "(uses-vars-ok? [\:istore_0 \:iload 0 \:istore_0])" "(count (expanded-numbered-opcode-sequence 2 1))" "(count (expanded-numbered-opcode-sequence 3 1))" "(count (expanded-numbered-opcode-sequence 4 1))" "(time \\n  (doall\\n        (superoptimise 2 class-name method-name method-signature eq-tests-filter)))" "(use 'org.tomhume.so.IdentitySO)" "(apply concat\\n       (pmap \#(%) (partition-all 10 (range 0 1000))))" "(apply concat (pmap \#(identity %) (partition-all 10 (range 0 1000))))" "(into {} (map \#(identity %) (range 0 2)))" "(into [] (map \#(identity %) (range 0 2)))" "(into {} (map \#((identity %) \:write) (range 0 2)))" "(into {} (map \#([(identity %) \:write]) (range 0 2)))" "(into {} (map \#(assoc {} (identity %) \:write)) (range 0 2))" "(into {} (map \#(assoc {} (identity %) \:write) (range 0 2)))" "(into {} (map \#(assoc {} (identity %) \:write) (range 0 nil)))" "(> 0 nil)" "(range 0 1)" "num-args" "method-signature" "1" "(count (expanded-numbered-opcode-sequence 1 1))" "(use 'org.tomhume.so.Main)" "(count (expanded-numbered-opcode-sequence 1 1))" "(use 'org.tomhume.so.Opcodes)" "(count (expanded-numbered-opcode-sequence 1 1))" "(time (doall (expanded-numbered-opcode-sequence 1 1)))" "(time (doall (expanded-numbered-opcode-sequence 2 1)))" "(time (doall (count (expanded-numbered-opcode-sequence 2 1))))" "(time  (count (expanded-numbered-opcode-sequence 2 1)))" "(time  (count (expanded-numbered-opcode-sequence 3 1)))" "(time  (count (expanded-numbered-opcode-sequence 4 1)))" "1" "(def cl (get-class (\:iload 0 \:bipush 2 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(use 'org.tomhume.so.Bytecode)" "(def cl (get-class (\:iload 0 \:bipush 2 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(def cl (get-class '(\:iload 0 \:bipush 2 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(invoke-method cl \\"signum\\" 1)" "(invoke-method cl \\"signum\\" 123123123)" "(invoke-method cl \\"signum\\" 0)" "(invoke-method cl \\"signum\\" 75084750234750983750982347)" "(invoke-method cl \\"signum\\" -1)" "(invoke-method cl \\"signum\\" Integer/MAXINT)" "(invoke-method cl \\"signum\\" Integer/MAXVALUE)" "(invoke-method cl \\"signum\\" Integer/MAX_VALUE)" "(invoke-method cl \\"signum\\" Integer/MIN_VALUE)" "(invoke-method cl \\"signum\\" -9283798274)" "(invoke-method cl \\"signum\\" -999)" "(invoke-method cl \\"signum\\" -10234)" "(def cl (get-class '(\:iload 0 \:bipush 254 \:irem \:return) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(def cl (get-class '(\:iload 0 \:bipush 254 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(invoke-method cl \\"signum\\" -10234)" "(invoke-method cl \\"signum\\" -999)" "(def cl (get-class '(\:iload 0 \:iconst_2 \:item \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(def cl (get-class '(\:iload 0 \:iconst_2 \:irem \:ireturn) \\"SignumTest\\" \\"signum\\" \\"(I)I\\"))" "(invoke-method cl \\"signum\\" -999)" "(invoke-method cl \\"signum\\" -10123)" "(invoke-method cl \\"signum\\" Integer/MAX_VALUE)" "(invoke-method cl \\"signum\\" Integer/MIN_VALUE)" "(invoke-method cl \\"signum\\" -999999)" "(invoke-method cl \\"signum\\" (+ 1 Integer/MIN_VALUE))" "(invoke-method cl \\"signum\\" Integer/MIN_VALUE)" "(Integer/MIN_VALUE)" "(def i (new Integer))" "(def i (new Integer Integer/MIN_VALUE))" "(.signum i)" "(123 Integer/signum)" "(Integer/signum 123)" "(Integer/signum Integer/MIN_VALUE)" "(Integer/signum Integer/MAX_VALUE)" "(invoke-method cl \\"signum\\" (+ 1 Integer/MIN_VALUE))" "(invoke-method cl \\"signum\\" (+ 2 Integer/MIN_VALUE))" "(invoke-method cl \\"signum\\" (+ 3 Integer/MIN_VALUE))" "(invoke-method cl \\"signum\\" (+ 4 Integer/MIN_VALUE))" "(expanded-numbered-opcode-sequence 2 1)" "(use 'org.tomhume.so.Opcodes)" "(expanded-numbered-opcode-sequence 2 1)" "(map \#(assoc % \:class (get-class (\:code %)  \\"IdentityTest\\" \\"identity\\" \\"(I)I\\" ))\\n             (expanded-numbered-opcode-sequence 2 (num-method-args \\"(I)I\\")))" "(def cl (get-class '(\:iload_0 \:ireturn) \\"Identity\\" \\"identity\\" \\"(I)I\\"))" "cl" "(check-passes eq-tests-filter cl)" "eq-tests-filter" "(defn one-is-one? [i] (\= 1 (invoke-method i method-name 1)))\\n(defn zero-is-zero? [i] (\= 0 (invoke-method i method-name 0)))\\n(defn minus-one-is-minus-one? [i] (\= -1 (invoke-method i method-name -1)))\\n(defn minint-is-minint? [i] (\= Integer/MIN_VALUE (invoke-method i method-name Integer/MIN_VALUE)))\\n(defn maxint-is-maxint? [i] (\= Integer/MAX_VALUE (invoke-method i method-name Integer/MAX_VALUE)))\\n(defn one-is-not-zero? [i] (not (\= 1 (invoke-method i method-name 0))))\\n(defn one-is-not-minus-one? [i] (not (\= 1 (invoke-method i method-name -1))))\\n\\n(def eq-tests-filter (test-map [one-is-one? zero-is-zero? minus-one-is-minus-one? minint-is-minint? maxint-is-maxint? one-is-not-zero? one-is-not-minus-one?]))" "(def class-name \\"IdentityTest\\")\\n(def method-name \\"identity\\")\\n(def method-signature \\"(I)I\\")\\n\\n; set up a map of equivalence tests\\n\\n(defn one-is-one? [i] (\= 1 (invoke-method i method-name 1)))\\n(defn zero-is-zero? [i] (\= 0 (invoke-method i method-name 0)))\\n(defn minus-one-is-minus-one? [i] (\= -1 (invoke-method i method-name -1)))\\n(defn minint-is-minint? [i] (\= Integer/MIN_VALUE (invoke-method i method-name Integer/MIN_VALUE)))\\n(defn maxint-is-maxint? [i] (\= Integer/MAX_VALUE (invoke-method i method-name Integer/MAX_VALUE)))\\n(defn one-is-not-zero? [i] (not (\= 1 (invoke-method i method-name 0))))\\n(defn one-is-not-minus-one? [i] (not (\= 1 (invoke-method i method-name -1))))\\n\\n(def eq-tests-filter (test-map [one-is-one? zero-is-zero? minus-one-is-minus-one? minint-is-minint? maxint-is-maxint? one-is-not-zero? one-is-not-minus-one?]))" "eq-tests-filter" "(check-passes eq-tests-filter cl)" "(passes? eq-tests-filter cl)" "\u00AC(import 'java.lang.Runtime) \\n(.maxMemory (Runtime/getRuntime))" "(import 'java.lang.Runtime) \\n(.maxMemory (Runtime/getRuntime))" "(get-children '[])" "(repeat 3 (rand-opcode-sequence 2))" "(rand-opcode-sequence 2)" "(repeatedly 3 (rand-opcode-sequence 2))" "(repeatedly 3 (partial rand-opcode-sequence 2))" "(rand-opcode-sequence 2)" "(repeatedly 3 (partial rand-opcode-sequence 2))" "(reduce + (partial (count (get-children)) (repeatedly 3 (partial rand-opcode-sequence 2))))" "(reduce (partial (+ count(get-children))) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce (partial + count get-children)) (repeatedly 3 (partial rand-opcode-sequence 2))" "(reduce + '[1 2 3 4])" "(repeatedly 3 (partial rand-opcode-sequence 2))" "reduce count (repeatedly 3 (partial rand-opcode-sequence 2))" "(reduce count (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce identity (repeatedly 3 (partial rand-opcode-sequence 2)))" "(repeatedly 3 (partial rand-opcode-sequence 2))" "(reduce (+ count) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce (partial + count) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce (partial (+ (count))) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce \#(+ (count %)) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce \#(+ (count %1) %2) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce \#(+ (count %2) %1) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(map \#(count (get-children %)) ((repeatedly 3 (partial rand-opcode-sequence 2))))" "(map \#(get-children %) ((repeatedly 3 (partial rand-opcode-sequence 2))))" "(map \#(get-children %) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(map \#(count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 2)))" "(reduce + (map \#(count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 2))))" "(prune-stats 1)" "(prune-stats)" "(prune-stats 1)" "(def xyz 1)" "(range 1 (inc xyz))" "(prune-stats 1)" "(prune-stats 2)" "(/ 99 3)" "(prune-stats 2)" "(count (keys opcodes))" "(count keys opcodes)" "(reduce * (prune-stats 2))" "(* 39 39)" "(reduce * (prune-stats 6))" "(reduce * (prune-stats 12))" "(reduce * (prune-stats 11))" "(reduce * (prune-stats 2))" "(rand-opcode-sequence 10)" "(prune-stats 2)" "(prune-stats 0)" "(prune-stats 1)" "(prune-stats 2)" "(prune-stats 3)" "(prune-stats 2)" "(rand-opcode-sequence 2)" "(rand-opcode-sequence 3)" "(filter is-valid? (get-children '[\:ixor]))" "(filter is-valid? (get-children '[]))" "(prune-stats 2)" "(rand-opcode-sequence 3)" "(prune-stats 2)" "(get-children (keys opcodes))" "(map get-children (keys opcodes))" "(keys opcodes)" "(map get-children (seq (keys opcodes)))" "(map \#(get-children [%]) (keys opcodes))" "(prune-stats 2)" "(prune-stats 6)" "(repeatedly 3 (partial rand-opcode-sequence 4))" "((map \#(count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 4))))" "(map \#(count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 4)))" "(map \#((do (println %) (count (get-children %))) (repeatedly 3 (partial rand-opcode-sequence 4))))" "(map \#(do (println %) (count (get-children %)) (repeatedly 3 (partial rand-opcode-sequence 4))))" "(map \#(do (println %) (count (get-children %))) (repeatedly 3 (partial rand-opcode-sequence 4)))" "(count (get-children '(\:iconst_3 \:iconst_3 \:iconst_3 \:iconst_5))\\n       )" "(prune-stats 10)" "(prune-stats 3)" "(uses-operand-stack-ok? '(\:i2b \:iconst_4 \:iinc \:iconst_2))" "(uses-operand-stack-ok? '(\:ireturn \:iconst_4 \:iinc \:iconst_2))" "(uses-operand-stack-ok? '(\:iconst_4 \:iconst_4 \:iinc \:iconst_2))" "(prune-stats 12)" "(get-children '())" "(get-children '(\:iinc))" "(conj '(\:ixor) \:iinc)" "(conj '[\:ixor] \:iinc)" "(get-children '[\:iinc])" "(prune-stats 12)" "(prune-stats 6)" "(reduce * (prune-stats 6))" "(reduce (repeat 5 39))" "(repeat 5 39)" "(reduce * (repeat 5 39))" "(reduce * (prune-stats 6))" "(prune-stats 6)" "(reduce * '(34.0 33.78 34.9 33.15 32.81))" "(int (reduce * '(34.0 33.78 34.9 33.15 32.81)))" "(reduce * (repeat 5 39))" "(prune-stats 6)" "(subset?)" "(prune-performance 1)" "(prune-performance 2)" "(/ 79 100)" "(reduce * (prunt-stats 2))" "(reduce * (prune-stats 2))" "(reduce * (repeat (dec 2) (count (keys opcodes))))" "(count (keys opcodes))" "(prune-performance 3)" "(/ 100 79)" "(prune-performance 2)" "(prune-performance 3)" "(prune-performance 4)" "(prune-performance 5)" "(prune-performance 6)" "(prune-stats 6)" "(reduce * '(33.141 33.4304 33.2245 33.3556 33.254))" "(int (reduce * '(33.141 33.4304 33.2245 33.3556 33.254)))" "(reduce * (repeat 5 47))" "(reduce * (repeat 5 39))" "(reduce * (repeat 4 47))" "(count (get-children '[]))" "(rand-opcode-sequence 1)" "(prune-stats 6)" "(prune-stats 0)" "(prune-stats 1)" "(prune-stats 2)" "(prune-stats 3)" "(repeatedly 2 (partial rand-opcode-sequence 1))" "(map \#(count (get-children %)) (repeatedly 2 (partial rand-opcode-sequence 1)))" "(get-children '[\:iconst_m1])" "(count (get-children '[\:iconst_m1]))" "(count (get-children '[\:pop]))" "(count (get-children '[]))" "(range 0 4)" "(rand-opcode-sequence 0)" "(count (get-children (rand-opcode-sequence 0)))" "(map \#(count (get-children %))\\n\\t                 (repeatedly num-tests (partial rand-opcode-sequence 0)))" "(map \#(count (get-children %))\\n\\t                 (repeatedly 50 (partial rand-opcode-sequence 0)))" "(reduce + '(10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10))" "(/ 500 50)" "(prune-stats 5)" "(prune-stats 12)" "(map \#(float (% / 39)) '(10.0 20.8072 28.3805 30.2772 32.0268 32.607 33.4567 33.847 34.292 34.571 34.7561 35.0472))" "(map \#(float (/ % 39)) '(10.0 20.8072 28.3805 30.2772 32.0268 32.607 33.4567 33.847 34.292 34.571 34.7561 35.0472))" "(reduce * '(10.0 20.8072 28.3805 30.2772))" "(reduce * '(10.0 20.8072 28.3805 30.2772 500))" "(int (reduce * '(10.0 20.8072 28.3805 30.2772 500)))" "(reduce * '(39 39 39 39))" "(/ 178792.5398261712 2313441)" "(prune-stats 3)" "(prune-performance 6)" "(prune-performance 1)" "(reduce * (prune-stats 1))" "(prune-performance 1)" "(prune-performance 6)" "(prune-performance 12)" "(prune-performance 9)" "(prune-performance 1)" "(prune-performance 2)" "(* 0.052935 (reduce * (repeat 6 39)))" "(int (* 0.052935 (reduce * (repeat 6 39))))" "(int (* (prune-performance 5) (reduce * (repeat 6 39))))" "(reduce * (repeat 6 39))" "(redundant-pairs)" "redundant-pairs" "(def redundant-pairs '(\\n                        [\:swap \:swap]       ; Two swaps leave things as they were\\n                        [\:pop \:pop]         ; Could be replaced by \:pop2\\n                        ))" "redundant-pairs" "(reduce \#(%1 %2) redundant-pairs)" "(reduce \#(%) redundant-pairs)" "(map % redundant-pairs)" "(map \#(%) redundant-pairs)" "(map \#(first %) redundant-pairs)" "(reduce \#(first %) redundant-pairs)" "(first '[1 2 3])" "(next '[1 2 3])" "(second '[1 2 3])" "(contains-no-redundant-pairs? '[\:ixor \:swap \:swap])" "(doc contains-no-redundant-pairs?)" "(contains-no-redundant-pairs? '[\:ixor \:swap \:swap])" "(use 'org.tomhume.so.Opcodes)" "(contains-no-redundant-pairs? '[\:ixor \:swap \:swap])" "(loop [current '[1 2 3]]\\n       (if empty? current) true (recur (rest current)))" "(rest '[1 2 3])" "(.indexOf '(1 2 3) 2)" "(.indexOf '(1 2 3) 3)" "(for [l '[1 2 3]] l)" "(loop [l '[1 2 3 4]]\\n  (recur (rest l)))" "1" "(loop [l '[1 2 3 4]]\\n  (if empty? l) true\\n  (recur (rest l)))" "(loop [l '[1 2 3 4]]\\n  (println l)\\n  (if empty? l) true\\n  (recur (rest l)))" "(loop [l '[1 2 3 4]]\\n  ((println l)\\n  (if empty? l) true\\n  (recur (rest l))))" "(loop [l '[1 2 3 4]]\\n  (println l)\\n  (if (empty? l) true\\n    (recur (rest l))))" "1" "2" "(loop [l '[1 2 3 4]]\\n     (println \\"Hahahah\\" l)\\n     (if (empty? l) true\\n       (recur (rest l))))" "(loop [l '(1 2 3 4)]\\n     (println \\"Hahahah\\" l)\\n     (if (empty? l) true\\n       (recur (rest l))))" "1" "(loop [l '(1 2 3 4)]\\n   (if (empty? l) true\\n     (do \\n       (println \\"Not empty yet\\")\\n       (recur (rest l)))))" "(contains-no-redundant-pairs? '[\:pop \:pop])" "(contains-no-redundant-pairs? '[\:swap \:swap])" "(contains-no-redundant-pairs? '[\:swap \:pop])" "(contains-no-redundant-pairs? '[\:swap \:pop \:pop])" "(prune-stats 6)" "(use 'org.tomhume.so.PruningTests)" "(prune-stats 6)" "(prune-stats 8)" "1"]
eclipse.preferences.version=1
