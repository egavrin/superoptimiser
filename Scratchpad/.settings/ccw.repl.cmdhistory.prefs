cmdhistory=["(map char (concat (range 48 58)))" "(map str(char)\\n    (concat (range 48 58)))" "(map char (concat (range 65 75)))" "(codez \\"fred\\")" "alphabet" "(take 5 alpha-seq)" "(take 5 (alpha-seq))" "(map \#(cons %1 %2) alphabet)" "(map \#(cons % %) alphabet)" "(map \#(%) alphabet)" "(map str alphabet)" "(cons \\"a\\" (map str alphabet))" "(map \#(cons \\"a\\") (map str alphabet))" "(map \#(cons \\"a\\" %) (map str alphabet))" "(take 5 alpha-seq)" "(take 5 (alpha-seq))" "(take 27 (alpha-seq))" "(alpha \\"a\\")" "(alpha \\\\A)" "(alpha \\"ab\\")" "(alpha \\"A\\")" "(take 5 (alpha-seq))" "(take 5 (iterate alpha \\"\\"))" "(alpha \\"AB\\")" "(take 5 (alpha \\"AB\\"))" "(take 5 (alpha-seq))" "(iterate alpha \\"\\")" "(take 5 (alpha-seq \\"\\"))" "(alpha \\"\\")" "(take 5 (alpha-seq \\"\\"))" "(take 27 (alpha-seq \\"\\"))" "(take 35 (alpha-seq \\"\\"))" "(take 5 (alpha-seq))" "(alpha \\"A\\")" "(alpha \\"AB\\")" "(alpha-seq \\"A\\")" "(take 5 (alpha-seq))" "(take 30 (alpha-seq))" "(alpha \\"A\\")" "(alpha \\"AB\\")" "(alpha \\"A\\")" "(alpha)" "(alpha \\"\\")" "(alpha \\"A\\")" "(take 30 (iterate alpha \\"A\\"))" "(take 30 (flatten (iterate alpha \\"A\\")))" "(flatten (take 30 (iterate alpha \\"A\\")))" "(take 30 (flatten (iterate alpha \\"A\\")))" "(take 30 (flatten (iterate alpha \\"AB\\")))" "a" "(a)" "a" "(a)" "a" "(a)" "a" "(a)" "a" "(a)" "(a 1)" "(alpha-seq)" "(nth alphabet 1)" "(nth alphabet 0)" "(cons \\"fred\\" (nth alphabet 0))" "(cons (\\"fred\\" (nth alphabet 0)))" "cons \\"fred\\" \\"jim\\"" "(cons \\"fred\\" \\"jim\\")" "(str \\"fred\\" \\\\n)" "(alpha-seq \\"hey\\" alphabet 0)" "(alpha-seq)" "(alpha-seq \\"\\")" "(alpha-seq \\"A\\")" "(alpha-seq \\"\\")" "(take 5 (alpha-seq \\"\\"))" "(take 30 (alpha-seq \\"\\"))" "(mapcat alpha-seq (map \#(str a %) alphabet))" "(mapcat alpha-seq (map \#(str a \\"A\\") alphabet))" "(mapcat alpha-seq (map \#(str \\"A\\" %) alphabet))" "(take 5 (alpha-seq \\"\\"))" "(take 25 (alpha-seq \\"\\"))" "(take 25 (alpha-seq \\"\\" 1))" "(take 25 (alpha-seq \\"\\"))" "(take 25 (alpha-seq \\"\\" 3))" "(take 25 (alpha-seq \\"\\"))" "(take 25 (alpha-seq \\"\\" 3))" "(take 25 (alpha-seq \\"A\\" 3))" "(take 25 (alpha-seq \\"\\" 3))" "(take 25 (alpha-seq \\"\\" 4))" "(take 25 (alpha-seq \\"\\" 3))" "(take 25 (alpha-seq \\"\\" 4))" "(take 25 (alpha-seq \\"\\" 3))" "(take 25 (make-tree \\"\\" 3))" "(take 25 (make-tree \\"\\" 3 ()))" "(make-tree \\"\\" () 3)" "Anyone able to help a newbie with an implementation of a lazy sequence?" "(make-tree \\"\\" () 3)" "l" "(make-tree \\"\\" () 3)" "(use 'clojure.contrib.combinatorics)" "(use 'clojure.math.combinatorics)" "(subsets alphabet)" "(cartesian-product alphabets)" "(cartesian-product alphabet)" "(cartesian-product alphabet alphabet)" "(cartesian-product alphabet alphabet alphabet)" "(cartesian-product alphabet)" "(cartesian-product alphabet alphabet alphabet)" "(def alphabet (map char (concat (range 65 69))))" "alphabet" "(cartesian-product (alphabet alphabet))" "(def two-letters (seq alphabet alphabet))" "(cartesian-product alphabet alphabet)" "(subsets alphabet alphabet)" "(cartesian-product alphabet alphabet)" "(map str cartesian-product alphabet alphabet)" "(map str cartesian-product(alphabet alphabet))" "map str (cartesian-product alphabet alphabet)" "(map str (cartesian-product alphabet alphabet))" "(map (apply str)  (cartesian-product alphabet alphabet))" "(map \#(apply str %) (cartesian-product alphabet alphabet))" "(def three-letters vec (alphabet alphabet alphabet))" "(def three (vec alphabet alphabet alphabet))" "(def three (vec (alphabet alphabet alphabet)))" "(def three vec (alphabet alphabet alphabet))" "(def three (vec (alphabet alphabet alphabet)))" "(def a (alphabet alphabet))" "(def a (seq (alphabet alphabet)))" "(def a seq (alphabet alphabet))" "(def a (vector alphabet alphabet))" "(cartesian-product a)" "(cartesian-product (seq a))" "(cartesian-product (rseq a))" "(def a (conj alphabet alphabet))" "a" "(def a (cons alphabet alphabet))" "a" "(cartesian-product a)" "(def a (repeat 3 alphabet))" "(cartesian-product a)" "(apply cartesian-product a)" "a" "(no-repeats (1,2,3))" "(no-repeats (1,2))" "(no-repeats '[1 2])" "(no-repeats '[1 1])" "(no-repeats '[1 2 3])" "(no-repeats '[1 2 2])" "(no-repeats '[1 2 3])" "(no-repeats '[1 2 2])" "(no-repeats '[1 2 2 3])" "(no-repeats '[1 2 3])" "(repeats '[1 2 3])" "(repeats '[1 2 2])" "(repeats '[1 1 3])" "(repeats '[2 2 2])" "(repeats '[1 2 3])" "(repeats '[1 1 3])" "(repeats '[1 2 2])" "(repeats '[1 2 3 3])" "(repeats '[1 2 3 4])" "(repeats '[1 2 3])" "(no-repeats? '[1 2 3 4])" "(no-repeats? '[1 2 3 4 4])" "(no-repeats? '[1 1 3 4])" "(no-repeats? '[1])" "(no-repeats? '[1 1])" "(no-repeats? '[1 2])" "(no-repeats? '[1 2 3])" "(no-repeats? '[1 2 3 2])" "(no-repeats? '[1 2 3 3])" "(a)" "(count (filter no-repeats? (apply cartesian-product (repeat 4 alphabet))))" "(count (apply cartesian-product (repeat 4 alphabet)))" "(def my-filters sorted-map-by val)" "(def my-filters (sorted-map-by val))" "(my-filters)" "my-filters" "(my-filters assoc \\"fred\\" 1)" "(def my-filters (atom (sorted-map-by val)))" "(swap\! my-filters assoc \\"fred\\" 1)" "(swap\! my-filters assoc \\"ginger\\" 2)" "(def my-filters (atom (sorted-map-by (fn [key1 key2] (compare [(get results key2) key2] [(get results key1) key1])))))" "(def my-filters (atom (sorted-map-by (fn [key1 key2] (compare [(get my-filters key2) key2] [(get my-filters key1) key1])))))" "(my-filters assoc \\"fred\\" 1)" "(def my-filters (atom (sorted-map-by (fn [key1 key2] (compare [(get @my-filters key2) key2] [(get @my-filters key1) key1])))))" "(my-filters assoc \\"fred\\" 1)" "(@my-filters assoc \\"fred\\" 1)" "(def my-filters (atom (sorted-map)))" "(@my-filters assoc \\"fred\\" 1)" "(my-filters assoc \\"fred\\" 1)" "(def my-filters (sorted-map-by (fn [key1 key2]\\n                         (compare [(get my-filters key2) key2]\\n                                  [(get my-filters key1) key1]) )))" "(let [results {\:A 1 \:B 2 \:C 2 \:D 5 \:E 1 \:F 1}]\\n  )" "(into my-filters results)" "(def results {\:A 1 \:B 2 \:C 2 \:D 5 \:E 1 \:F 1})" "(into my-filters results)" "(def my-filters (sorted-map-by (fn [key1 key2]\\n                         (compare [(get results key2) key2]\\n                                  [(get results key1) key1]) )))" "(into my-filters results)" "(into my-filters tests)" "test" "tests" "(into sorted-tests tests)" "(map into(sorted-tests) tests)" "(map into{} tests)" "(map into {} tests)" "(map (into {}) tests)" "(into {} map tests)" "(apply sorted-tests tests)" "(apply hash-map tests)" "(apply sorted-tests (map \#(% 0) tests))" "(apply sorted-tests (map \#(identity(%) 0) tests))" "(map \#(println %) tests)" "tests" "(map \#(str %) tests)" "(map \#([%, 0]) tests)" "(map \#('[%, 0]) tests)" "(map \#('[% 0]) tests)" "(map \#(%) tests)" "(map \#({% 0}) tests)" "(map \#({identity(%) 0}) tests)" "identity(test1)" "(identity(test1))" "(zipmap tests 0)" "(zipmap tests (repeat 0))" "(into {} (zipmap tests (repeat 0)))" "(into sorted-tests (zipmap tests (repeat 0)))" "(def sorted-tests (sorted-map-by (fn [key1 key2]\\n                         (compare [(get sorted-tests key2) key2]\\n                                  [(get sorted-tests key1) key1]) )))" "(into sorted-tests (zipmap tests (repeat 0)))" "(def l '[A B C])" "(filter 'A l)" "(filter \\\\A l)" "(any? \\\\A l)" "(not-any? \\\\A l)" "(contains? \\\\A l)" "(contains? 'A l)" "(contains? A l)" "l" "(contains? \\\\A (seq l))" "(some \\\\A l)" "(some 'A l)" "(some 'X l)" "(some \\"A\\" l)" "(some \#(\= \\"A\\") l)" "(some \#(\= \\"A\\" %) l)" "(some \#(\= \\\\A %) l)" "(some \#(\= 'A %) l)" "(some \#(\= 'X %) l)" "(filter no-repeats-and-no-As (apply cartesian-product (repeat 5 alphabet)))" "(filter no-repeats-and-no-As? (apply cartesian-product (repeat 2 alphabet)))" "(apply cartesian-product (repeat 2 alphabet))" "(filter no-repeats-and-no-As? (apply cartesian-product (repeat 1 alphabet)))" "(filter no-repeats-and-no-As (apply cartesian-product (repeat 5 alphabet)))" "(filter no-repeats-and-no-As? (apply cartesian-product (repeat 1 alphabet)))" "(filter no-repeats-and-no-As? (apply cartesian-product (repeat 2 alphabet)))" "(reduce and (map \#(apply % list) tests))" "(reduce + (map \#(apply % list) tests))" "(&& 1 1)" "(& 1 1)" "(reduce true? 1)" "(reduce true? 1 1 1)" "(reduce true? (1 1 1))" "(true? 1)" "(true? (1\=\=1))" "(true? (\= 1 1))" "(true? (\= 1 2))" "(true? (\= 1 1) (\= 1 1))" "(reduce true? '(1 1 1))" "(reduce true? '[1 1 1])" "(def a (\= 1 1))" "(def b (\= 2 2))" "(def list (a b))" "(def l (a b))" "(def l '(a b))" "l" "(def l [a b])" "l" "(reduce true? l)" "(reduce + l)" "(reduce and l)" "(reduce nil? l)" "(true? 1)" "(true? l)" "(def m [a a])" "(true? m)" "(reduce true? m)" "(reduce true? (seq m))" "(every? identity m)" "(every? identity l)" "l" "m" "(def n [a b])" "n" "(def c (\= 1 2))" "(def n [a c])" "(every? identity n)" "(def n [c a])" "(every? identity n)" "(defn all-true?\\n  \\"returns true if the sequence supplied passes all tests\\"\\n  [l]\\n  (every? identity l)\\n)" "(all-true? [(\= 1 1) (\= 2 2)])" "(all\=true? [(\= 1 1) (\= 1 2)])" "(all-true? [(\= 1 1) (\= 1 2)])" "(def a {\\"a\\" 1 \\"b\\" 2})" "a" "(map \#(% 0) (1 2 3))" "(map \#(% 0) '(1 2 3))" "(into {} (map \#(vector % 0) '(1 2 3)))" "(def t (test-map '(1 2 3)))" "(use '[MessingAbout.test-map])" "(every? true? ((juxt no-As? no-Bs?) input))" "(defn no-As?\\n  \\"Predicate that returns true if the supplied sequence doesn't include A\\"\\n  [l]\\n  (not (some \#(\= \\\\A %) l))\\n)" "(defn no-Bs?\\n  \\"Predicate that returns true if the supplied sequence doesn't include B\\"\\n  [l]\\n  (not (some \#(\= \\\\B %) l))\\n)" "(every? true? ((juxt no-As? no-Bs?) input))" "(def input '[\\\\A \\\\B \\\\C \\\\D \\\\E])" "(every? true? ((juxt no-As? no-Bs?) input))" "(def input2 '[\\\\E \\\\F \\\\G])" "(every? true? ((juxt no-As? no-Bs?) input2))" "(passes? t input)" "(keys \:map t)" "(keys (\:map t))" "(keys (\:map @t))" "(def t (test-map [no-As? no-Bs?]))" "(def t \\"fred\\")" "t" "(ns-umap t)" "(ns-unmap t)" "(ns-unmap 't)" "ns" "(def t (test-map [no-As? no-Bs?]))" "(use 'MessingAbout.test-map )" "(let [m {}]\\n  (sorted-map-by (fn [key2 key1] (compare (m key1) (m key2))) {}))" "(let [m {}]\\n  m)" "(let [m {} ] (m key1))" "(let [m {}] (sorted-map-by (fn [key2 key1] (compare (m key1) (m key2)))))" "(assoc m {\\"fred\\" 1})" "(assoc m \\"fred\\" 1)" "(assoc m \:fred 1)" "(def my-map (let [m {}] (sorted-map-by (fn [key2 key1] (compare (m key1) (m key2))))))" "my-map" "(assoc my-map \:fred 1)" "(assoc my-map \:ginger 2)" "(assoc my-map \:fred 1 \:ginger 2)" "(assoc my-map {\:fred 1} {\:ginger 2})" "(assoc my-map {\:fred 2} {\:ginger 1})" "(assoc my-map [\:fred 1])" "(assoc my-map \:fred 1)" "(assoc (assoc my-map \:fred 1) \:ginger 2)" "(def m {})" "(def n sorted-map-by (fn [key2 key1] (compare (m key1) (m key2))))" "(def n (sorted-map-by (fn [key2 key1] (compare (m key1) (m key2)))))" "n" "(assoc (assoc n \:fred 1) \:ginger 2)" "(def n sorted-map {})" "(def n (sorted-map {})\\n  )" "(def n (sorted-map \:fred 1))" "n" "(assoc n \:ginger 2)" "(assoc n \:albert 1)" "(def n (sorted-map-by (fn [key2 key1] (compare (m key1) (m key2)))))" "n" "(assoc n \:fred 1)" "(assoc (assoc n \:fred 1) \:ginger 2)" "(def n (sorted-map-by (fn [key2 key1] (compare (key1 n) (key2 n)))))" "(assoc (assoc n \:fred 1) \:ginger 2)" "(def my-map {\:chad 3 \:bob 5 \:sammy 4})" "(into (sorted-map) my-map)" "(into (sorted-map-by (fn [key1 key2] (compare (key1 my-map) (key2 my-map)))) my-map)" "(def p (into (sorted-map-by (fn [key1 key2] (compare (key1 my-map) (key2 my-map)))) my-map))" "p" "(assoc p \:jeff 6)" "(def p (sorted-map-by (fn [key1 key2] (compare (key1 my-map) (key2 my-map)))) my-map)" "(def p (sorted-map-by (fn [key1 key2] (compare (key1 my-map) (key2 my-map))) my-map))" "(def p (sorted-map-by (fn [key1 key2] (compare (key1 my-map) (key2 my-map)))))" "p" "(assoc p \:fred 1)" "(assoc (assoc p \:fred 1) \:ginger 2)" "((assoc p \:fred 1) \:fred)" "(def p (sorted-map-by (fn [key1 key2] (compare (my-map key1) (my-map key2)))))" "(assoc (assoc p \:fred 1) \:ginger 2)" "(def p {})" "(assoc (assoc p \:fred 1) \:ginger 2)" "(def p sorted-map-by (fn [key1 key2] (compare (my-map key1) (my-map key2))))" "(def p (sorted-map-by (fn [key1 key2] (compare (my-map key1) (my-map key2)))))" "p" "(assoc (assoc p \:fred 1) \:ginger 2)" "(def p (sorted-map-by (fn [key1 key2] (compare (p key1) (p key2)))))" "(assoc (assoc p \:fred 1) \:ginger 2)" "(p key1)" "((assoc (assoc p \:fred 1) \:ginger 2) \:fred)" "(def q (assoc p \:fred 1))" "q" "(q \:fred)" "(assoc q \:ginger 2)" "sorted-map-by (fn [key2 key1] (compare (m key1) (m key2))) m" "(sorted-map-by (fn [key2 key1] (compare (m key1) (m key2))) m)" "(sorted-map-by (fn [key2 key1] (compare (q key1) (q key2))) q)" "(def q {})" "(sorted-map-by (fn [key2 key1] (compare (q key1) (q key2))) q)" "(sorted-map-by (fn [key2 key1] (compare (key1 q) (key2 q))) q)" "(def p (priority-map \:a 2 \:b 1 \:c 3 \:d 5 \:e 4 \:f 3))" "(last p)" "(first p)" "p" "q" "m" "n" "a" "(first a)" "(last a\\n      )" "(use '[clojure.data.priority-queue])" "(use '[clojure.data.priority-map])" "(def p (priority-map \:a 2 \:b 1 \:c 3 \:d 5 \:e 4 \:f 3))" "p" "(last p)" "last p" "(doseq [item '[1 2 3 4]] (println item))" "(false? false)" "(let [t (test-map [no-As? no-Bs?])] )" "(defn no-As?\\n  \\"Predicate that returns true if the supplied sequence doesn't include A\\"\\n  [l]\\n  (not (some \#(\= \\\\A %) l))\\n)\\n\\n(defn no-Bs?\\n  \\"Predicate that returns true if the supplied sequence doesn't include B\\"\\n  [l]\\n  (not (some \#(\= \\\\B %) l))\\n)" "(let [t (test-map [no-As? no-Bs?])] )" "(let [t (test-map [no-As? no-Bs?])]\\n  (passes? t '[\\\\E \\\\F \\\\G]))" "(let [t (test-map [no-As? no-Bs?])]\\n     (passes? t '[\\\\E \\\\F \\\\G]))" "(defn no-As?\\n  \\"Predicate that returns true if the supplied sequence doesn't include A\\"\\n  [l]\\n  (not (some \#(\= \\\\A %) l))\\n)\\n\\n(defn no-Bs?\\n  \\"Predicate that returns true if the supplied sequence doesn't include B\\"\\n  [l]\\n  (not (some \#(\= \\\\B %) l))\\n)" "(let [t (test-map [no-As? no-Bs?])]\\n        (passes? t '[\\\\E \\\\F \\\\G]))" "(defn passes?\\n  \\"Returns true if the sequence provided passes all the tests in the test map provided, updates failure counts as appropriate\\"\\n  [tm s]\\n  (doseq [test (reverse (keys @tm))]\\n   (if (false? (test s))\\n     ((println \\"failed\!\\") false)\\n     true\\n   )))" "(let [t (test-map [no-As? no-Bs?])]\\n           (passes? t '[\\\\E \\\\F \\\\G]))" "(take-while %(< % 20) primes)" "(use '[clojure.contrib.lazy-seqs \:only (primes)])" "(filter \#(while (< % 20)) primes)" "(filter \#(while (< % 20)) '(1 5 10 15 25 35 60))" "(no-Bs? '[A B C])" "(no-Bs? '[\\\\A \\\\B \\\\C])" "(apply no-Bs? '[\\\\A \\\\B \\\\C])" "(use '[Scratchpad.test-map])" "tm"]
eclipse.preferences.version=1
